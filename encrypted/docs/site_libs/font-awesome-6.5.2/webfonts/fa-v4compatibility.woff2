<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d27f868b52020c995e35200980a1e0ade73d3ecd8f13361cac15fc4ab36d7ce8b20b8a383687b35edf71691f89713d20563b0a0de683b57465f1ed7e2a594e72b6ce9da12e60e76b7bc57bef7a448cd6bf7ab1f7c80a694e5042c998b2d67c2d7f53255eabf9b80cdce0e5d2b6576267f813047ac952ba22b69f3ddb1bf9d8a718d94f8e02baaec8237e4d0d9982717ccb952335bfd478e371b13ebcc53fd213aee4c7a6769c72737e4467712c3b0b46c3ccb152cfd727b0a6b85e8e22bc708be170f748936b8ce94659bcbe5db580ec2cc672955e4e525a23103ccb691504b7c9b4d08c9d2d38b61a6034d6b88d233405ee4ca0ff94033e993b065163bd114426cbf6444614d9db45c53c3d6077e82f80dfa21d4307141c6935918d016f7dd228c6ab4d21d99f963c7c0133054fcb112e5d858f5d6cd8ac42673b8c81956e6d78b65c88722c2417867227dee5def7d9e3c51ad8a5999f69e872a64e5f8b760ffdfb187be7b33ff72364b371ed0ff0817599be980b75b5ccd13f9065aa504689f4873dfbbf190f4befa5a89149762977fb3b30174db8a6e0859c708dcb80fd37cebc676f41bb5a2dc265ece694e03d7187ac1421d1f629068dd9cb042b6f84bf6bcf4cea69c7c137fc08990155d570663437621f8918f85cf2506c74609a29b7f95cb16700767ec2b7b087c632358ef17487a95a1f22a04507c8608aff16ba2e10260a703ecaa72f950f629fe7f04117046577cbf9e20089952aa95166118dd1b62ecd639bce1a38ed85a3c5eb5043e7daf4c8d16410b2b6d6d1dcdb998f636094ccfe15916554dd29d166f1e27810cc3839db3b3da01934ced3b47ca57dda74c40250cf0406a61ad1be91c820b71eff749131f2679f858ef7755aaa2cac9851877202ea3648459cd8ee1723e3bd016b61f0397ca203e41e0254586b345f4a0d394febb66e760ba1812a95b6e67985a44e59331f4e39fc63f6cd88abc33c1a7b65c2e8043000d94b84ed7014c862d8632fdf5a192b52d696127e1d84f8097a45c5322d3476978bddb86c6234aa0246e072fafa5c90744d1f1babfcf34ad872ba2f7385a490e1693082fc4436d745861504eef981e3f9bcd9115ce33417f14628ffcbda08fb5abf81c8df49934dd8d38bc1103bf9058e99021f81d62a3fd41e23cd4df13469373ca8625d04c2883601e212c7300a9d93180b0b9c988d4b10c4d26b34b179eab66acdfd416b0ed5549de412c820c7232e8e3028c09544124d91bba7ebc0b65302919cf4e3a50501e472734df09f52fbadd4c208660a57156dc412a1c77c9db855c40d357c7a563dc3b7b42edf4eaa41581d00efae28d6e4bf6b4d6f983fa1477e7fe3ac751400c8a995fdeaa3b8ddcdba4d91650ff9e5c9542fa34bd330b3e3253e54ddbe4971cb0cab045a1f49a89f56b6aa5f8882ee359606201388d59514476efbbad3f2bff02b9e628691c75c68d89b737642ce7e9fc096121cef53e2e0d36f74bf6debfd32cc26828322b078e7cd071cf2761135f7e093eac6594b9c3ba99fe552db3b1a2911a01341df5468238dc3c48abf7be6ccf4d39cb7ed7b130b19ee25a98231b3cd104ac5622547e05972d5619cc02dc8303bf24759ee50c5746f4aebef7558097b4fe7e0536c25733ca514429c43e4a34329182b8c0dc981eb31dc856d6f39433b2c7edf990f3d2c13eacdadb7b67273290b7a9e9dbd31a6bcbed500ac13819e846d3fde10c313054745e2c97be9e8083a3671a61a77da4735f9eac0657363bd20eabdf4864f7036c46fe8092ea066e82b62cbee93ef2ae7c4bb374024c2435f9921449e833745f2947e47a946a1eec3af8d50e63eaf6049eff1fe2c7fe4ed15951d0b15b403ade82a94e1ba1c4909f3c5c214a15c749e78faad1f819acc4626503319fe279a0d14b9eb394782cea9434dc5a2afc08105ecb23061ed2f60557c6e399eef96a0df52b61821ce204032297fb0d66e70fbc5507213828cf361771b15a646ef7c21774fd6c57d8e0b0eb8427a5c5becd77941986709c71cca4313de9fd6794e5fb1e6623e8781660ccf39b94b937c572a5d15fb4031b5ed756ced4b1b96d0286e8663ba8c8b540fce9a15ebbb971ba108bc7425e285e5ac9e130bb040e0e2cd53a17511227c30f48dff1ffb63640391be4ba3af26fd7149c29f565b1d1f79ff021b4fa5d4d0575f755e846e2faa344cbef8d456f5a027b80550b443d2f8ce740165a4502c2ca3045735133ac0c96fd1e2828e0f5e8ce6fa48c305b714b2ef2a2518e7a891ca9033cc1b7e3da7ff9696795de316bcfc8e05a1556148a1bee9009ee532ede30de5e6d1d62f8b1523c714d0128fdfbc3bbee03098f23ba25d62e4a061a9ee19ceafbce32c9086869aaf2b9f38a1906a297d0d58aa35d17648d106950eb06351015e67d9307b3feeefda675392080da98380f255034c06745cc83a2a9c2911445c8f5be65970dcfc6144f776ea0df0e2f55ab2d8a495cefbe08e4831a2d3b404d7c45cb46794f9a596191bea048968caf49e42785e5c56b92bcb397998f655177d92650fc251a5018594ad13350d6de5ec324d263cf92f675f844df1c0f062c5d46f37609a6a184975760dfd7ddd00f74c5922998e24cbd65944e065ebff15eb7843d3ea5eabf48715e6719f55b96f23faeaf2a83ae01444a61506239960066a20cf091c68ab0ac11f5a92455e06cdd15b27fe521f7eae624a9ea169457cad246c6ee3ace3533c355d988baac15e689a71d28bad7b735379eb803c45d89f1ffc66306a11d524165f1b50aaf66bae3f3ceb73a6635178c049dd7dec991541c52c9ee03e6eb660dde2653ef33fc7db3c19ad8e8e363b8a52200e79c97ab38a320225329cf400260078d8b28a2c65384b6248e597d14636e69b74e5b4e128922397ca36ce57170521270b01a8b70a192c0d8d9f571c4d1b5a6c501478181a2319d982e9ef07e0193878978a2cf30e920150da9520b6e7b9c03dfd29352dae6e51ed7fecdc17c8f8f094b5454271dcea8ec16c7b98cc194040377e1962126aa2728422e971aac74e21a459bc05e55c9375d6ff0a82faa792156258f94164c2d38c29d535a553aefabeb1d1d906f58ce4801a2caa4c54936257834c78e70e29cce43a158ccda445155d408a440c81fba959b5d84fbf020ae3822fd3f7c7b0898d0c964bbcb1e879f02f48461b929ff2d029d05a20ad212010d3a39f02de82ad4ab9a2d3a1798e1093b91417db054cc528752be7da31f2c8a136d355e905995ecbab0b2cbb856734f406a6c0723b493c56c0e5240b3c18e4adae361d6ca4700fdae650de72249c8c6947e4a880da88bcc99ffee646550eb1d48608620c0fe79ce399a1fa9e948ec093b6f6383583c51f35871ec9f736aca3b5960c8c9d6fc1b587d7f2b44a16dce371bedeebc07e98e39c8c2016c509d947c6d5360670d19c5f8e8a4cbf0d44109c01241e8913012cef6e6658bc1fbec60cf443244d538566128766114b31bdd5d452b23b4e372e487d58e4a6d7610fc38feea7f9142272e343c7867567ffc60c95b60ef1630ff47872951743b665047d375d38ea9778ba56f06a611006d82cee3f5ccf205bbae448174aa7cbe429a603ed76b82d8ca9bbff9f5d1488cef8dc26f39807018d9324fde0c7dab92b5e793603cd667557b213fe9714e6a0c2f6f0fe59e86eaeb324a67fc83d4f8ef08b82db50c08669882916c2ce3cf35974b835dd151c2156537fc3d53828efe6a9e5351a0d0db24894c8c6fedb35d5e2f6494c10369c0d208b115f5d143d8f0d6e5975d17a45a3705a7f844c5fdb2584d74225f80654471f24f0f1ef8f9602732e52df2ce97232e05739bdf1082bcc7a2357cb1cde0c4b4085d4b2333fdcecbe3c4733ea49301915dddb92d0bf447890ebd6845efb7e5930332fe723dc1eb4d063f10fe7624b462bb884f7c6bcb3ed7f6e6e68a1543ab9b4d4839b795ab1f44a607d0e5f4a49e5f02bff65472269ff19cdda230406f6a62cfbd9d29ad5d36bd824f3b6308cafd5cea0f695c98145b40e0131e3ce82c5e6a9fb44323298c44d107ba34f25126af31d9f1d0214e54dad6e33681e2277d0299f47fc658669d0e976335e494b92c531478bf22e0ace03bbb6dc18c4dd8b51f8342c0bd13c03a0e6b357bff589a4dc741cf39c40c513e80e107a400e7ef971ab965afee23f05fe9a32c446866f228b6b296a579a2a200aff094d2e8a3a073e914c4e79c8e23d089badcfee8292bbde815398092bc96cf4442d20568d8938ad4c95f08ea910239d1304119a6f1552f2525cc172a62894279c747c80f084da79b18cc997171a538b9aeccca4535e65af8c6c96456bccea5115af736665faa8ac42d5fde0c1e6ebaf2d39d32fc112de4db98dc99ae91ee800f8ba7bc4ecad3cbe6635e5d8fa4476599f231ba08436890b5a90078c1a63bf3692dcabbf7093fcbd96f6e00981ceb6ad141b3f52944d257dea754c36e6ab8ea8fc160e65341617683baadc4f8efb8b006649d35056e5f146fb65dff3697eb7818ee2cc7501de8342a2dd2caecba6c0bbe07a41146f4c9627a6a0e7b2aaa12011f3bfe55a712308af78dfc56b9d364c59b201a6968cafc5b9f8c561984898bcdea71f3a900ef1e21bfcbcc602c6d864e4e59aac08a287605233a8a40315a577d48d12133f71cc6347c5be2b306f2c0fed3d6272c6db9a1fb0c2435be9d9dd393bb277bd70221d44b056fffd36b4f20e8f07deabcbe9e7a773902eac78289a768a07de33de445f02a517f098944439c4c1ad2360456633e38b6b0416a5ad7d5a9bd50a10790028a84acfa3542c1aa8c68139ed2eb410e463adcf11948898af957239a912f8266874a983ed0628a75f7c6ef016d1694a9b566a72a542b8725e295be433f0423d789df27059df36d0018000cc1ed1f5f36a5753819280263627b41efcf88edc707d0ae97388ba10788424e20511e88daa8cbd1670df2940c11713c03642ae4d111b597743ba9b65b9865767d7e4796e959173650df87716aa67588e1db5b604fbfd194d446f75782c614c04b3309f217ceb77175eba4a638be6e5f0c2581881268d428e7d03c085feacf6c1d98fe4c3cc06447cfef4e1b722eaa4ab65aa4b17c5448db120a44e3a06c14974f809a0c522fac58f488ed1080d7998d7d0b145c5608ed79179c4158b7b941b51879f4a15f829c0c3df6344556efa0fe6798322f8ac966ab280b5315563da2ee8636696a61219ae382379d98d61ed51ccca1071cfc01d90bc66dc6fcbb5ad5bbe7e22be8240082410be329fa204f71f8211d947b25da3e9dd201f53b7e15f23a0a024340b079a7ed2ee4e265a7337811e09bcdebdd12ccc235a6e6e54c4a866f939327bdb1ba06930e1b1e71c6afe081ca992302a5c83a9e932394073bf907d560c3be71774ef03cb7f6edf448a7f1d341909749b08641861e2e29cfe58df8cef6003408d64b11b6e68d2176e2236116db324b3cabff503ebd42be8d2dbceb584b70522211c97f27d0d421dc1bbbc6975338ce17fe295b45cb58174cf9c6f42e6ecee72d585bca974e617bc90700b731e472741b57a7d0ccdbe3eb7548612da970a67951e8153d3f65c4013de7acb86b6ed59684a7abbb2b9b7fdd45e6c3ba1de19400f768cfb90fbc55cdbcca030ecc177e67245cf807e7dcba4f8e8949ec1c0d235c0459d29df4f9ad329692fc5670b53da4f8e9b7f58a81dc455b8940eba716b6ce560edfb1c30206a1d1aa15a8b801b5d13dfa259868debd7ba9ff31197dad5671fb86afd77330fea45693b0ef8809f3dce37af7e34837a6e1f05f8edd53590b8eee73a3969fe5803622ef14bfd1572029e5813e2ce7882f26bbf98835161d7973ea0ea2d7cda0031b5d23615ab37765b1c38b4961758ff95c6fccd93ce6aa8f17f62025f46865cafc4861d0cb65e6ee8998ac254fd6c9721e7b23e501a3ea89b58241bdb69cdece16c8dabe9eed9d6848883276a9742a7b27411468c2ab5121591b83e5e5505fb4a39f0eea04e1543ac9b121ccc9f2706e910ee9b6e4717cd00fc275d5cd86731ca665f21ee10cb67cfab411ab85917d4b189af6a24a866f36515c57ccf68f845b3268436ab6f24587d5ab046e476fcce01e37881230bb37fa9897d15f188fdc929a5129bfd49017e3e9c2b270dae9cd0d715a9796524541e0dbab8d0c76187cedff8d9ccf74c40e673fa65738154f3b2eda5748b55c8c84653bba25a644345650892a2b505fca15abc205672750f80efab4a8aacf05e87a1c016a6c3a42a49e9e771ed9027a3b6b30c51fc365182084810fcd1f21ba42f27659dea5ca669c59fc72860d3307f46dd95bce1fb2f48c617d90ab0dac7c4864ce424bfdf1bfad8b5bb4a6dc4ffeb50e0733c22c8e9cf862cc5ad8e1e93dea032b309aac10eb5e10fe34473f2a236e9977352ff5d83031e1357623e8c118fc91a8ca8770f5cf426bcaaecd58cb7911134fb17ad8c12256950f8511ae934cf791a87494d6d55da8ce944bdbbcd7089d0805102baae6d7954ba3fa5b07fe366b6692baae4c887ee4000559368ecea33847a7932d65e0966b0e6ad1c6cf92e978bf8f3c5148f161c6510d85364b32be0829e4ad8967f64ead0e4d364c6928fd41775d3c1fba6951f3ab73886729b4124ffd04741d3798fcc7f72960881b1f7112d9358f6a0aaf9b0ef540f9d03342840f7c03f602c0d11ecfc7735d9f52a720a7a1b865347404daafc610501f8a94c6d95c412e3ae39110899196e1ab4a47c554c66babe0929d24ddb8895f86a32768432449f0f5d51a0ecea2a3786b6109ee0f500757461224490a953d01c5d89d9f0c180ed692c5b979db92956ffe56629facec871f854eb5e76d122baf45c1a5ecd6f093bd202c589a9261e0768150e73435a69bc613df935b8bd7394edadd33b37aa9631ec37d2f915403bb450813e96258fe4cd70165a06d36c436672677166c773ad0b5999944b18678c3c95f131b2d45ed8d9eb22a30066f9eac25cd3a6f74b702194e627064d8432704555e34b9e6f6ca493dcbf01e5dc0ff551e1c0528253d1b068aa92399e9ea5ea66deecf91cfdbf6ac132d22d0fa55df9adbdfc6fe36561856438c15adeaaa8bd80552b8ff959fd2e026dcf28309701179e217e0902a5e12d1c31fb8822c88d5bd6597f24d35434345ee9c8d6b4796a49b3960e633439a731b1cb8560506ec8d4aa41a35ba2c4fe836650986e218439d4ac39974dd28cc624cb6c3b12acb2aebe853cd3c50ffe6392311e70534953e7f3e00c3e82a872a26f1b111f0bcc659e6f713584a7b86f1a695a397d2c6cd52bb714cdfeed288d25a1bc9bfa04e43548f81d9167dcac697a34a7c9bebd050ab5e5d83068d4d832b404141973587da5f691d11564da16f08dc651301d4abb5a90754595a09051bd38f13b38e9daae9f20fb1eb0c7f55997312a08a00eafa69ad2433ae0b28225422fe37bcd3285f0a0f10120be3bfd2fe6604ff5af7c4095a1e520427ba7a28a37fe6b51d1c843e3d4bc323ec2f312cf05ff9253613aaad5efca7818f4fc6d315aa072b2355fb79d4c12662792af9b0e9b78297419c29e417a3fedccac8f077109ff147f8e1436f411398067b3dbc9e595ec181c32baf15da5f106dbc80ceceb8eb9142199a2b8218c6b39498704ec2166ed9b550ba7b396e895f4ac1b5984eb3b33f5b6051eddc84c82f7bff48b9205a220f8f25a8f805c9bb7fdbf8e32405110469a99e3caeec674732e5cf7e8390e5cbba23a4396917c03973c0da18b265e5154bebc8ad58277ba4303be85e29c49f338ac1a5b8c7211b5babd826ecf1cb8d736e1189eb1bf73aedfd9fe1a9c31267e5ab9d6986d388c613c742f18d2201223a9ae6fda7c59ca751c674a8eb6e85190a8335a2c917efc46b3b11e3506b6b396043cf921c589dbfb1d58eed445dbf345801b6897e1b1c93ecf3ef1da21df859b72b51cdacf75ea528452b282020807bcc310ede0a5748f5d2f01a788b7035fd32d3eaf64cc0c6a93c6c490fd745d7e08b2c6e6e049d4d058dfe7ce47a3cbca06aecf58d9d848fa73a5556f4c2f9646ec4812e6beed249571c6638c5721def0edff3e97b6a5bf012f92dd89b13a56e2fd6ce9125cdcff89ff460f05073395e5cbf3a2dedae2c0a553546343da9b4a05b691e2453f5519a959e7550112b10d1dc0ff75e1e44f2e10ee4757c293d4b070d8d42d38a302d5ac61a763ee955f9d724766cd5fd3b9a26c4186e8b58c546c65060cc7220369955f80533fbaada77e048b5a290f56933b1511bd469740ef5adfa0bb9932ad7b8ca392de865400243d6ebc2c96d892943292b016eb0cf07216a233e6e6d103c0278a46957aad6156da2a387251a581fb81ddf6fcb304e0c2442a5790d40595b1301aef4644ac8a0f818a9bdfc970611db0bd526f014f52e55c8028f621d827e6f664874311a9d326aa4f90f597d24e16dc829b9a2208a9ef0b428801e9bfd5128f707bfa479a649092df7b131be0059ae1fab73dd5e06c92b50f5cdd48bb7b354034353ecf8f48b264101335bf88b1b2604b795249f9633ee941002fd0d95f9afa4e573300f3863ca6bc5de20343d0aec2af5213fd74c615c2fd2433800dac080982b6f416b3b811c67145519472d80f843fd9ff4513e416396ef6c0bf00df87ca085efd292182b31b7a660f0492bc4ddcef519c319f305ee84850ccef875fd6a40865150594b9514034ff6aeb70a6bafe708df760bfa8086c80cf6745644bb9933ea7e4b8017b86546c8371db42f1628570b9a4c88ed3d3e0d5e24e0270547c40c9dcda14ef8538bcdd9b58f46632efc6f44508bb50fc5db6d583240acd562bb2ec651e54794fb91bf57a85c4b745bc92a0c8e16e29529453255779a9adaad197e0bc099c34374db18b58def09b85f78e027a397c21ca5a7be2a9614fc28f8bc1d87428bfc354292303077af349a6fc12375e02813aeaf4fe13bff8d38ff6ca8de16d5e456046a7653b38e77e063a1364da2ab052e42f3cb226c5397f84db03b7d140c319727de883ef4c929405f1508432beac2389cca4fdf9276b913341298fcb7f32ab244b2ae9e3df0c9b773c0731439e04dd3aab24b0d26a527286e9fcbc1e6e0ff256bb798703859889505f1cb1a2ea645f77f5b6d768c9d96d759335ea6fda35a90c858c91ceb964eb733a320f11087aa570c026b8c6ff13a80589a998b944a0f03d0fd8d2966a962eb665fa13e7e66464cdec5efab3c192c0fa1494fef5600a7a74709483f69883ce5deb189b45745793ab77c4145d714c0a498790c1ef82b5bc0d002975a1a2967c31e9a1eef576e1fc4c3ee1a4c14c0a1874adef4ff617aa71d99fa7af91a3f887d54105d5e9152a5181307f98e04a9c460f15ab177dfa6267cf111e6ef14c40971cdccf91e0a528764e2598b20a50176c4d945756bbd754b3b9e311bb7583f84d81ba40ec5430cbc42ecc92951688fbbb8cab0e7c3177ca81cc44d49371bef74448552e06910197eb72c9df7eb34c6a04bd585b51f60d613d1cfb4870a637c8c5720ad33e573bda4b0d27e5b8ecc9ffcc96f522a9c13ab24e631058a01f0664cd178e6fb07371280847695d27bc7ccc3d5c8c469854af46df89cb6083a5e8a144eaa3b256e2e3ae0568636b097cd17e54349d0c80aad955790b4ce20b1d61f8785c216a26fd50912423525ecb82820b829e49cb5c02bca08221931cffa8af2a4f4e3546cb7afb996c2f9a5c7c2624545024b16ccc6f6ea0918a4af4599668d7db4e6e04ce1fd7dfec49f0ad6fc7464d93d22354d45f35a7ad2f455eed398038e55d28416e39c0ad4a12019dbae42881210d20a5318ed0693507ded10d829b7e16e6c0308edf0546056138a6d937095423bc62e8daf7db7c5c5c9c43a129ce1b5001e278c705f246547032f81b042f72b1ea35a98fdcb982805037e28ea8f3b4104abf91cf2e894f307aae63bb107a71b3d5075c0b0dd22bae0bfc0a4ce85a76e1fff4a166236453f132b8a32365337f0523f785e30eafb9dafeaf862a0987a96e22f8bab0c3bf4fe2ff40bf83c6a766b2eaf978d801631406dbcf8af1b59b479f1df65548352fb27e22b137928653d65694d79fd748994eb3c77734be756fabfa132a39c21cb37c496563a132a60a80bbfe09adf98509ebe92478801ea4d6a9d837361f68c5cae26c531203c53c212df6d1765513a47c754f621b94fe9dbd23ccd67383ff2862841429a1945752f00feec97e70a173d3191be4bbf88162829db0fa0bfa9321fe2826130ed050f52d80ba4ce66537fe69ab9c229145ae9343df4b536df5f587d70eea9c6379cdcac63ee593d1903d9fcfb7caa676c010b1dcc1d5618dde80cc181e13c86dc27ef811e314031518cf6d0839df0703bdf4707058981e54834326c7e8ae8469ac3ddd2a05c63cb4f2909256edd7e42d6391c4a42c17ede12b7615530dcee01e699b981ee5cfe110bd476a4d9cf0e548de4b2d27da42348a223a35d5500b8bb1842d07696a0124472a4bb30f4ecf94e9889a7e73d78645ecc087c19c246a908851cb26eb352ee77563614f60e39f3ecce98401f6e3685c6f8fe5fc559b8d40445da5864cfabce4f8fd2fc92f169d6fe34bfba1d2d2b27a3600320c5361aa78bd7ef505549fa7323adf4470706fff06be2ec37e42dbb313a3f96c098944c01f064ed84d4ef4cd14123aa5ef588e13ea35933fe6bdec54404a05c79c5acc3b51e576b958f1ec585abb9443033f93f969e3f07ee579f40db6396940376e19aca1c0fd304a724da0b53643f277af9e155eb2d8bd2376d6ebf57ea497296e4b9f12aff50d43fc14926ee2c9d5928b6e6601189657f6e94bd291abb58448ad61c069aea3415a7d280c98e6a8caf556b3445bb1fa56472177768ca872a883ef48331f7f6fe456a8645a03ed9735d8d31d657f314cafff5a82e56884e8da6705ab0b9d2a1e95b22281cfde6875356fd9cd843b9e62cd9b63ec78aa4d9bde0cedc248c3205cebda9d36e6887344b1ba7ef09e5842f2e8afa91400ab10efb660d62a4d2b8ca6b799a240ca23d24cc029b86ae2698ef990fdda9442c222841d11715356d2cf054ff73962b6f86e7c33f88be27bf074ed6fd107f24ba4393919acf0cefbd9d2b16279a7cfe573c675c8a9d2a7630edfc6b4d71977f53545d0ee2e902bcc5f3d9164ae3517a82ebdf986b7cc34d89ffe68119ba1667544d08cff3bf1f9d84825ebd783ad412c05d3400ceeaf4ce6e2c8350f9e03b89c3fb1f3602a7b7b1e35360e385ed8c430c7c1e07cf61459de9f103e4ed32679f89c3b10b03403f4b6802eb7db238025041fa0f1ba5ce60dfa4d12864c929cd7cfea729f874005ede8978a114f503fd389de29e8538e5141cd42b58082a081d53a0b208b3562699cc3a99109a9da4f34f2848deb82f24ea5226a749e6c3e1ac2481bda90cda019ce6c39ae3e4d87be4174eb95a6807b6a734b19b86104f3f19fd3d760e91e1113132dd4b8fb0c6564cf6bd2a7871b4eeecd510fb84495120b7a3fc606c89931c51d470b1e14a9be712976bc65caca62402a74983d0be97d9cda6d66b5b24b861a3e62ed888c5e863e7c90c967a628012d37258ae027e5a385fbd315ac8cf3c4f47d4253f3907d958a0817efb1d4b487e078a4a4b0830cd23db442adf9d7efc1b6f1fd4f7c296c45c88ea1ffbec9b585d0ce776345b4d1890bd1f670dc567ea7cb1f98c00d38f3fffdf0da3f9951a813f5667f8d6681dc36d2abaa266096ca0aa74450d2cf68b7271f0d04baf69edc0301689f9f60a5125bc0b927405d13f69f77d1c34995abe52ed06968be9b573e3fec354f5f5377a09d0aa2ba2a546795efb6abd4a469288106df3774862152c3b65c2ae36fa320a7a86e0289bc547c4dd79667dcd63e9ec1d66647467194661b967d0681332fb704e92c20388018cf97371c861124dbd5866839c3a96e19082746c2786c0bd4bf2e5d97e6a35ff8042aed8aba90a1b3295650e96c02ea9947ed5f9f56f8f9a9173f6e84b82e00c85b1cc94671e0334df18f1ff933fb02ef0f84a5d7be3243b291103a724a3f0ecad230c2443dd24e2532762494ba86a703d37272595a80ead841ed1875edd9cfbd68a376c2c8122867e1cd0a13d107b8a8d4802c11a5e10cc997636a38b509999733bb663534403c97ad0f8e78cda5b5c3535d4c3cc06b946c38952b565bf68bce4d6bce8e9bfba805f29106e85ee85ea28a762b85332695fe3cdfae3ac9974dc3c51123378f09713271bfa6ee89a5b6b8b73c31aa3c3b151469e259b03d50b16f2fa753b2611cb4be88eec5a9c9d7b7d36c31d5293e76f6b8b5024be3e0586aa92f6f86f0de99d0e2d3591209fc661135fc1705f7b42733d67bd35692e33444c092369424d483320e5667d67d7c31c6aa69d755eb531951fc19373f9dae03da159429a45ff194d8162e9df0bc29209c3a1c5a2909e42bc7c2d8f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"12345678901234567890123456789012"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
