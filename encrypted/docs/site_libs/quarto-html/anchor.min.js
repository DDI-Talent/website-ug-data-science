<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"24ac327e4598f5a8634c3ab9a254a6a651c2377bf96c7bbdc84b5452493f30b50b8dc467c44d924446240f6951e6d3e9c9c8b252935cd1e3a7526c303d73af326ec49efeff3ed873e95c00c80f719765d5e7f2b8f07e3b234a76c3e6411ff00b295c2f9aee2214e239c7559003e05415c28a78bfe17ead4b7f7478a377e8788944e6e8efe1314c5acc1f003a0746c1aedd3d7d6f36acf930affeb52572b7f34f0e07bd8c8f04072b68590456d8e995db244b075187247797855cc3ea65a1833fc7d212f7888b69c07211c32ac2c2b728f75a132009945ffdfb6985ee7edf87c09e983b1919477d4c9aa4cd8081c35c9dea698c0e8ba8ee9c0ce6df5c75f9a9a68d631500f0225c6721e1eaab0edf01f42e3482b28c52d805f1661bfa8668cf9e7dacfa86e987e39259d24b1fdfa9b518038e32dfbe3dd4f0061e742567dcd158da3e0e6b9394401990eb46c3b196fe90f290562c4392f86f17f3a73534739c89ec8a57d5b43ebaa75bbc68c72e9743f0a59af1031ffe3038b7d93687a99aa4b734a439491f7633a8133082abe95137fb9ef9c983a50aaa6cd3e215a655d4e4c6e2961fe94857c4ce00269d6ea31a5102be9bc7d1a068e41690b15967792a75cdf3c4226f7d223a1ba54f27d3d22930f864055601f7838ecedaec8361a4c258e827a032fd961705792cc3bcd28184c4e5c53e2e56c0048a5bfc21014c215284db4a71f2d81c77a182f355ed8620d59c7f980ea97f753ae5199e897dc5bde856bc264ff08aacd33da2441f420490e436ce6b11ec103ddc741d99e7bb5ecdd228a06277bea3b6cbb05975012721940ad7f97edf4df0ec4604d82b880baffc2b3b144eab60682531c19e25349627fbf2b889ca7b0f1c42a18f7677a9c592cf02edf74ffaace0abdc1f2ca8f4455d827bf73050fc2bb2cf41a984e2b120bda3862dcdf24bd12fa9871293ebbf84002d8d24581742507272c30134501996d0d2c3312d0d8a31030e07a6889f7a701ca66972d4e2822a6b107cb6be5bc0ea6ca0a551d8d6e34fd0174b7bf4cef327d362905494c2dc4d82aea0863bed19ed4f8f925c45198dab879be8d4704e3006b67d809be068f81d495ad6849b03f7bf30dbefddfd69b4c8495d39045a6d7453ce0ae6237e44f97425c3fcfb53687aa876ac22b01ceb62eb5de3c13e0954192bfd43e85df3f6d717e34c8ecd9e938338b78cf507c43ccfde1dafa5fc7290ee3165259fd3aab2045359b12de6cc09f178ff5d0b0c356f2fdce843584825361bba87c3b2c064938e453abc17fd9f733994680e5f049365970a8413a0f9a12830a5f7b6ca1a7544c7cd781296cb0598531560f2077411eed375baaa95020fa2583628ab9f535d6227873b5ce441e1595d0be87bd1bf2859ca882da41adb6fcbc0f69f2d19dfb51b2a252c5473487488ddf1e0febc4eb740d335787a9e34966a54773f2ff91173e2846e0c629ad48d24a3c256dd93cc027723ef7165c8bff150923d9cdb26685c4e92ffc4d88c40797439098b3d50a6d1dfe18e6fecb5e7b3804591bcf282e603dcd8dba421aeac037cb8c3e7dbe89f671274503a6d4068d2cc7e5e1c848034336a31fbd7347dc86a6e9e7a4f46be57e32a159e0c4e5ebf5641d336c5c7f2f10fd8d77175842679e8b38c55106b6e419cbabd5b9641a78a1b94d1de0932c5667f1add1b78d70afacd71946aeb15ce136ad385e939fef5128d1d8e7001593f711e2aafe8405cecb8b7856f39062e426efbe85879dae7eefda18a942dfa9bfd057c300f820df21cafcdd7c486a45a85af71dc43bfc5d3c96ae86911907bfb7bb260ed0c24ab1935d213da2f9a6aa15f6670fa1862667c99239e3e4491fbc37c3d767f7543ccbc3e845b73c424801846ae8cf26fb8764024735c6dbf51403e428e71800b3c560f9dae62a3eb7b50be705d1edb13b7902ebbe3622c1621a1c537f4558c530312763a9377a0ac9f7bbaefa172da36bf96c0ea6bcc55f9172208860752fe62c0e754ce1af5d94c1770667c2d9fdfa7368389ce6117e0ab351cacfd0d6416f15ec980c82a3e47aaa9dc6d457e7c1eb15bcaa7b1846526c3492f7b80d849c5bc0d2f2f4d1e6e4233c42fe6182b7be8c3ebcbb09840ce2a0cbe025379bc853f4e447ba1e4232f3ee044033217e623d5526ea572ba0050d30a601fd75a290ea03f35840bcbe6c163724811f07ddb290acacf4a1bb9949148fda3ade0aa6407d5e505f0b72a04022acf1ad728181dcb63a9ed5a0c21f39afba4771f0a38c4724f3a2ea80ad8bc31df1d2f82ec25f3e3b9182da10d7658033ffbca245a71910689b144557164c55dd5cec9387ffe79f38af6eb89b58e15d802e5acff6f8e5e91d25dde781eadd17f8c0e58accf9670b1e3c820f2df25633a238ff1359decf409813f5e86b7b36851a5fb52b89b7e1ffcfdf06b66a2c606be841030bdac05f162186c21b09026c3fcc680943f01a7b23c2b02704a479bfabe3f08fc1a803a3e8d3e273652cceed0e452b9318630ec1eafbf30d5a59fc31596d894a282e56c581b7bc81caf3f2f96d1075175ee189b5e78a06ed9b0eeda335cfadf7194c459924184a2e6dcd2df3d39d873708afe29c0d9a27072b647ac4de54c0ee1abe2448317b24d3b8605cf14e593a36a577de4d6b6684b1bbdb607ce3734948145b53160f226d5318d4a38ca58968b215be04c2b8f8077ad1e0c4cc0cc8550e7d8528924c6208655c78ae1fa856c0c3ec7c9d441da14cda8942dc00894b4fe8ad49797779d231dbd9a7b4079c4091a895fd8648134a0660bf8ef2f5d79d090393e5f1bdd13666e628ce2908f2737862fe921f5d509460f3147523666aaf751b8755db5082f7055c7a4d5edd89ea10c24677e971a9ad67675164f160aeed1199f62e8c03e2a2d7038a1d0bf6c61c8c39401e99ae10c0fc4ddd8a54842e72ff69949253ce60401227a8cdca32882cb6b4ec02e96d87c3fb6ecd140df92bd853dd7498e3af677dc320b1e72086257c2ee0dcd85921811059af1b2b86228cc2640bb59746e0cddbc907c73b3d453511c929319c2dc34db1ef02af70f95f452fb6fa02aa74d828da93badf2d500089ef8fe603ed70bc0d7c12c1b2ff6092b881d3d3138f15e8f6a5491d783e8e3f3465bf1ad260ad178c33bd2183bd44b23a06f5a73fc925ac9c14666abd3972711f19f2c90e285fa9744b5be5aad5e23e6ee21b32d3f332c0563bf38e74b21dc917435272cce75b7cecb589f3fae9a962fb95ee1dd892f5c9c991206732ea7dd6bebc780800d6d3afff701359b83b79e5d3cb6e24113441163b152b90c3c9b91e0f88c2df033131bc1dba4b13641f7550b61ea02cfb6fef239016cea806c9ff98c1b184a721aa3d3412c3623a7a670190a3a7fa44b27d41a08b7e69522478559b3048917630f7c932260ed638b081cfd250e58c469b05adab657291a9755e8f957f695dcef13c0cc468013ca71163e7eeb7412ca68b04807cb3576f7eac313527a747fc6208195252243e23f3969984353ad1667a67c05a91e0217936f6700e491eaf6fa9a7569543da56847879acb36ca24c5a53de72fbce88565f40538c3e424d5dfcfe7a1b1541974814bec8a6cc96226ac7d956172fe41514f147bba33a25be1b1bc5c21cfbaa546df685d5a589daf824a77d2c51bb8e0344e090227d8c62d8f80c610ed95220fe90c404e0f64fe73272020b09604c47fa313f400190ac16c8b8efdfeabc12d05cd8c9a6f06ef613535ec0cda871db5740d3ada6d88265e020fb8f44dfa977e49da55f09ff086f2fcbd1c17f9a1c4f60dff029daff6d36f3aaaadc054358010d4fe8f7ba8a356050e0f84e3bcade0910b311e98c489154990d49a3182461a1882c60df9c893624e6d8319196e49f5be1e33f6e8d60f34f1465aed8a6422470091c981dbbe898393701ecb322c5dca0ce80ca30a61c3f99bfe05986c934b28782e138addd826a58c37db2f1df6b7f0393773f264ffa996b41e9eeff9d1bdcedc0848039574eabc9c7ca05b20f3d64e2b457118fbe9db6c8917a2989086a1f681182624c602617a15331fc1840ae6ed6803e63a51074b193fedc0598eeda4b9d0f28e9e3709fafb4f88a911a9588520c53ae55f715a0591f60d1cb7378fe70a07aa4baa2d603e323e0afa3b439d4c3b335ea1a2a45a38f5e0f729d9468d2cc8327514e62d709eb52021e6e38a74015aea2b00c75054cd8da6fea59507e393de59f08619c0da15f604a2bb17d5b55001ea4ef7be25e40a3a34ab7b70615d6e29b785fc2556f94a667ca6ed1645f7a05b1fde81ae22ca63a762c2b570519c139fbba5f6a770853866d7d94b5facaa513ea4fffc438a7b58bde9d0e22bd356e4483c65770487d645e01dbb9124d728bcebd78e5b87007f6de2aad95b7a2a14b6c28498a1dfb28c60eb3ffc2ad7d6670fa72b3391a91da8e355655811b794ac934abdc94e41cfcf0f8af6cc84efcb22e1f35db4088dcff35bd5b6add7732adc4e77ccf88bebb42ed7eb948e63325b3a5452e1018dede37501bcbc3182c62d6aebe34243be9a5731ec11e2c1076355aac4421dc339a30125cf42cb206ea38530af1c3d3138c9f8198a21a014b3ee6bf239524f774bc42fbad337deffb5e70139913d03bb8ea6e81180ebf81156083da72cc2168fe11968aa1d715cc663fae23b886bbb52bf578c6e4e9b41ceae6a6b1d9342540fc696d0c782ccba1510370bffc0d023d16fa014217aec3aa0956bf83df6f5c50527e70a3d41f241c02931e62ad44862f0528b0cc6c14fb1a87a551e0a70652678f35afd62f9ab6795c473818a94b8e5470d44c2fd3495f76a8f456f4ab69c8fdc64f51af331382c8f58466b6df26ec67ec4d1078acf0729be7130715f64216434347f7fc77087518d1164c1fff191b54955d56aacd1d99907d92ac2a36716b2afcfeecd67540a44e54c420a689a6f3d756c898f6bf4340b73232b888417c60f51dec00c3bc8eb1450812cb1d9c5e3080ea8264ac9dbc03605a490bb8a68241a8e10d069cac1a761c41cdbc2a7b21939e09bf8674d9fb32920b8034d0042ebef0ebd0d592b66ee889d08583fcdc671ec0ecd8e4078cc59a997eb1c13cd81fd6c185db69e1175c3c6037048525b79e7e8ff4650cfe1dd115c482c1eaa2c5a91cf26bb8d382e4a28b4ce792d2512522e1b10f36661cabdee6c4539ab317ab63a5760e744c0d1c0149d6ac8cd76a490389c73640c970418ad2d665e2ff82558ecc11863ec66879b217697efd000224a4f457cf0b5b7c59f21d4feee0634a858b0d151153c477e6212b327a21f00afc0e819a1ccb24ded44109ea6a774875cf0190285dae32bb6f98c4b321645fb4506bc0f1751cd37f5438aea7b0e1f25bfef007f066ac0a44694b84bebed11ce3ce0c239446c480a392c67d889cae5b30c56f8589974ae6e8b3ae0493e54c83ba59fa6f3f22157da3f57c0c0e2b1da018807e8c9b819a5be1ce3934ea0cdad1443b636ff346d6a1f9b6a0a459b07b927bc8796a497875748beba0d88a37de95f34a0b9afa05b35503f6a20d9e123bc52615d37d8b22b30cbafcc1b4e28b7ff2449ed2a1458c9d7ab7823317d0a7137008c96e8a831099f755d8e119795b228d7e324266ffcb683bd6720a7e358c5e1650d7b0ed1e2ed45427c9eea5491187e8d5008c946d9ea87dba7efd02496505faf77e85a03d97c6afa080c51aa554cee83bd046a8578672e692ac73a54411c765ccc13cd9d2b40035cf46d7eea7f05066330034a194c5243133b0bacc3413a2db7bf0e0fe2c1c109693efb07d091b8e026b40d9c46e20fff9624911baba0f72cdef41d4110c289d80f3cb6b8fa3d38cf7449708cd86212747c521947194b976ecc32fe62032f4e04fb4b724378d5d82b417b0aa12c765808d9246364df4785cc6b805a743da5323bc3365855f3f19f11e7d7d9fb5904da08263c7eb96124bc60aedb29079526bcc989d8069b8478e10e65edf5681f8e7c47659181723e6d252bbe7ca29e299b8cd52ced2aeed0860112bb0af6159d82e682e86e25be8cf7a45adcd1cbdc3c2f70a2ec459e3908aebadf8e7aa6aab68229b1c9c5e59a76533c77c65032a4eaf7dd5adb3919298e472cc1f37f25395a7759a116675cd057c3a0422c69257a41c8b30a3bbbe4ff66f7f4109210a7e81118bfdde5be2fa88c7be9a914a7a76dc6e4e7698c5ff98a806e4a4fc6df9e371988d5692bc4df4ecac1ed792a07638bc925dba39b5cdf500710682ffa1e9c1365a271654a46d8e71980ddd52f179fe8299d542561c9b5451fa47aa7fac71a6f2ee0a9f1f19655a3a1ffdff4323a7f7f8bbbea600f4647f94b6415f84d6bcbf978ff62677c7e888972758bc2b170dfc4079c76b35b14927297e80343e116b585cf407c8ed58ee8ce321fb5c036d0c96e36dc5b8383228915e6f5b1d6cc2ba18d400d61c3960f698c11fdf647b07fa5133928cb00febe11c25dcf56d12e35a2c56a1963f3923d59b6c2819f0c8479df5fecde5af6edb84335e9c2c5f2c525dc6260eccd040c6653d16e328725e392e206239e8ec2678e9ad7725ffe22a3b3e4ea107903dc059332460a1f1ad591e5c2893ef8b28788b70f1f241463b8e6f6cbea185be3266cfeaa4446fcb7d6fa01536563466b3dfa24c8c8bf174625b7d9748a4fa2a045d4a695476ddf78cd1d54b5564354dd49a319c96fd9bf23e2a37f24ce13551fd2a8a58c4e5b2c2eafbe2fdcb3cd76fa3ca67c530bc5053f1c670b9218e0034af6964237888473a0cd6c71e1f65d8b0a88b6ea3a31b0ad4103acd6106cf8989ce2b195deab2a09d19c6b937414d8408f8d08a26563263a2e24c0b1afe734086f3d02002c1008b9b15b8b27034497f825061f0208ae8310471e3b8cf8f7c7869281710ea71b4e9ce7c54daa3dbbc2076169b56d0e3a56994312257ab9247411a915f2b1f89fc7d2265d8f1ea9ec5976e9f33e6fe35591e0fd6371bb8c932dc45ebcc8868b25b2b5d34b24906dae44976fc1553bff126ac937988c0e772984251bc79e7521ad66f98cf17297728d6ae7b51eda424eaf7b896a3d3bebdc9e2bf18ba683d9cbcd74318230f05a282eff96b19bbc7cac91d2c5fc2ded56dc39c1371877f86729636f8de584fa3a451e0868e24104e2878f6a752408f297f917ec11690f273f423b108150b9b9732c97e6bd9785bbdfa6f354be2185017c6f62192fa9063405e467fa69ce884c4baf4d6d5f0a2733a4c844bc9527e07c9e4a4564e5d8696230e0b66d63dc3b6ed38bfe63a56cacecddd0a6fe896ccb4e994bacc87aa6bbe878281b85865354d4de3f4b99bb30ecdae76bdbc1492a3e8f6c6a91726082328145465f849a912231561d59f178d0aad9b7ffd794b2864051cb70fcce95a0dcb98d1d373e1e1dca767f7810fb5c3248cfffbcbad51a0e12315c5eaae23a6167280259104e340bcafb9610ad76f4f0402b42332f23005d592c38d183d1fac7a9d06b3ca8d32c62cdcc9e1fce46e8fdca52facf6e3be6091f3df8266ca0728af8341a959a93583c0d1778709ca2ce561146098e6fdd1138850e41f502e12b577374d43738c5ef2a0a7e285e4dea1812ac0f0140a2adfb3c8c5526c02f72915dce0dd25eea8aa732441f2e69eb5381df00fee57d57a507ab3d8f0aabd4187ef539dc8d4457f4e507ecb7e60a7934e717a78048a615f08fd094a89a115d45b4d4e6ea3554fe90612fa3097b7a56da8fe9a9af3305529ff1143574d49a5e2c2633a717f1f5c17738f58dd646ea903561de65d16e7c246368966047b162cb100805015df7a1a2b9862bba171263dbd053cc763ee8537f23a503a0d79b4ff086b5448887dcb7195efcc04d0bbc245e25fe413fdb56a6047a4491398e50216c110b1a0d4d65064d0946c615cd2798667058c655b94972ddca63167670db6966f0f4efb45ce96503c7b6f6796bb8d07fb44be0910c340b2381f4ba5e272a602c63a87af0d35db4cb92ff897b8d1edd09623d4c511675cec2d73df9941ca3855bc6ef7f11465d0857fbceac51c52ff766de8278e3539ddc56f4e508ddab9969caaeb1f8ea76d34b7db1a3136c036dd45ba670efac905147087f1b0ee7106e6e20f04cd6711750b91b7d8cd8af4318f68f7bbf216a096419b590bafe081a953cb67ab0fb10921b03e7d028840d1bb243f09e736f5a91125174b255f7c8c3150f6b2af4f5ddafbbcdb465dbac13b93cb0504eaf6667998468f4b7b6bb06b7b6dcddf084ca907f3d76e4f105b76ad97e84af910c235e1382d1811cdd5d6446fca1ad9538094c3bf8586ef07fdaabeea0b021bc8665ccaf67f74e17517d8674b19a23ecf01c4fbdd917cd1df4a5063bb82197b760b4d750665012be0cb77d4549ac0a33ee34","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"12345678901234567890123456789012"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
