<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8710f9edd94f8a4317f95c72c9d3a072d77f8f43d037dcb14790c906d3e427aecd3551abeb601953c3a24ccbfc7a2cfa52bcb7a22d35aff16b75fa82edbfcf25cf3df5264d0c23bce03f75412239fda8d63dd57ffc0e2d3f20eedbb2361bc570d03127fd41d88beb812f1c9a783d432d36fed7a3f3024344f0c1cafbb414150a7e6663d060cecd8fcd4fe4b59f93bbd357de4121d78e3c5cf11e9244d8b41f27395cfe234249bebd70aa0108966a9b0d56e139e1f93d1bd92d9b2b7158bb81944d3a42ad1dc8ca1b5601bd898b7a08f7de38408d16a499c3e5d1bde87efc5565b4bb6a76567c3d86b4f825d3c711c6fe67138dc2279191419187650fd7bf4b2542867bb504f30d0a2a719de40f5f4ff7b2daeb25e1ddc7d6d96ad0ffffd137455398b1c168e9f1771e7112d8e4c995583466f9a2f11d08751bb151ba835383629a6315c36505f2fe5f65e469d90f03217c43cf89319035a94d0ba39967cf77530eb09417e3f7022910f1205f09e3e1917797394586390e2a66a9201ff00643fd433c3cfaee10a988541bb0d21f13034a9f5a0ef14cbef217848ac44d78fd3d925c577df1644a539450302e210cc8af56d7b67fbdb61946d3ed281dac68f846aa6ca983710c348c60d7a32b43ea84390040778aa21e20115007f9cb0c99c3423dd7c847fd2124a144cc8febf69899348fb13abe7baddb209a186d566aebb5b6926384a10cee61047b70cf59e00798b32a9043c012fe1f4f3ecc68bae42cf6c74d2c56fc0078bfec48ebd2b14512f5efd0c1d562071ddc8f90b2e73766350fe79b2d7990d2943362aa4801915a2ff8f969694d9f5f4c879382359e13df23541ba55b7573c157070de8252d2712ddb7c71c9a29b392331d7e97ac32eade62887554fd429182c38e6b19afdab12dd2b66397027e5ec139dc65d32dc92491ccc26518467dc5a1c2b083cb9a7043df767cd475a8028434bac1e8d80da87f30cf4e1e72461ee6308288f90e06930dc613d54b1771f5930a5999f2af3790f215c5d840f2f139ab04327df57ed0fcc48548d2f96d89e5048c68e4789dc3d826d46af2c9a0ce08fdd2cc835df17d3f0206d4988251e995567ca8058f37804674ffd7fb03464f91b9f3185995b5ecfa76b6b8c5031e544aadf4d44fe113993127109653b28b2144e3ea17b2b459a8b8586bfb26117ba6f01135d4cf514098dd5ace897f6598d3c51418e737ed3faaac9563e1f271714421ec3fd7ae4621da7d7a1fc569954653639e67e634098628a8dd3bffe9091d9e62ecd79c4fe41855b8da2fc15fced38866f96cce600913c2896c6553078cb35c15b19b0501b1f60341a068f6485d921765d4c068af0b95f3ee1043507e2533d713773d847cca79442608aca7e845ba380c204f0df71af45e3b6cdd770426591d2a8d8079286b73c2500fef28a982296ed5176d15eb3368798729f23bf17327335e5e30b887d34e2f3f2f1e13ea943d24e6494454d41877f23d6cdc1e96980989c289bd33aa9e35bfe894812c6a8357e40fa3d2722cf02a9009463a8105044fc4209d49e47f2374b95460bb767000746daa19402a7e1444119a464b5d6d290005f4961a6766b7add9b4622038a0ae567d845117ea93dd225e69efe2636f2663e02c1ab9183d927ba0a9cddb7ed25e82520f4717c395e7e6a335d42ea932d8e21fda0b72dbfbab965436cfadd9f1981f93b280c94d737a9fa0807e0ffe13f512fb5ca0a1ca9c768fa8fe98cf2f3120cd002036fedb1f69dc8607e1a614fef915d91bf4aa0528e7f377425967a82fb1d70884b13c5d52612b02f4b850e7d6078da42c86050e62d842728fd6bdbf9f04487c00f7b955633f8bc3ab175e477e61a0f7a6221bbce11136cd89a7fdcb34b0d3ee2b31b744b1d7cdee5d1724498781b4222d5649c8dd3d2c76258dd7a0001280036df921786ab1cbfc2b634db829d3f9e98a08656033b43ea98aee35b69721ebc7ffa1cce8ded517e7fad8ab8098b1e9f86a018958794ec24994f950a3cacd1865e0f393e91580a2a1ab259f5ad64e6c37e33f1942c369427d183064a99ea19b64dad1259bb146668287768157334d596d9c4f5d68330245eec9c98d8447cf074958d8a9b1fb310224f0b2698cfec33c0102975d250183baf432b850b4ac927b001cb76a233cbe2b1ebe81b2aa3d86b0def7f3a840dc7b8a13914b477ea28eded4e9f1e621426dfa2a183d598f6fc5740a1931e489fe78019558975343b194191e0af62d54f6007180cf866e1feda3ed959aeaff8d4d26d5ae0622761df7bc858a51ad8c867c9203f13f027910024ad1d0f054f25b06cb34a000b8b6f7faa76143053bdf67bb44cf4e3d6a6b33565f3cf1ba0c81afe0e5a5dd90fa8b8f2cd669964736b092ff39bdc6a9f33a372031a0a06736df2b1fa65dcae7aee860622e165144ad833d43a57b483d6b114aad27d4fe8bf19930decca6df7af45e489aaffefe27d497b8b919aca3fea5e94c7cdc0db508a2a05e11ad67b17ca11aa857661f12e709b6e4ceef2732ee3dfc2f7a583cfb8e9d9da84c58e48fba20912cf9474203b50271c6977146923502a5331221e7e03d492a68d1da64a15ae569536568d706fafc2c48d07e47fb7d6ad7640054019443069597e15edaf6c23e99afa6af72d5b7dabe5440b3763f43feb39a1ab2886ed314d475ae1cb401fa57d9cd224b23d58b000d758b84524c35e7a753c718c121c548d21195dcc3ec0b820b96777ce15231b0eface1148658b4a33a438adc3dfbd6d9a03c6907bc271f3a4413ecac7acbbb2848e107111a7cbbb2b08543544a60decd65be2f9609e6ef340d9ec0d2c1d29a7b00b104603d3c3ee42f0b30bc6e6bb1411608a04cdeb0af81d8412270f7e0df5e919d814d7056ca441d6f0fe7aca266e57f1d9cfad6b35a63ceee537c4cde19a4fd2155cad1fb6a740f145d1c319ba33f9c5ea2b2085f78db63549f879fd59220fd5cc296b0c7a924101d0ad7096840b6c16e30c72fc9ebfd8d321da410afc6353c46a49999758f3594889899cd31a36820720918ef7b32e3e305499a4a1b97924613620146cb888947031695c1c9415cb31821e5af5f9b8a7c2f3b8d0d1344a97a9e3e80ca47d0b8133a4298a048ee7004b1fe7d84b1fb8ba8669acc55ba664778d9177dcc13b724ea868b8c6d71a7501bf00f40cdf2336026f82db9b1182021652ce74f2f1c0ab654284be1ae72ad36903bfeb413b85a50f197b4fb0540293db8aa9b03e891a3dc0ff89e32d5efee25217e90030eeaad52add54bec799970b5217b5014762a4cf7ced4ec7433c5034df6593a1a98059641f8cc774e616e14bc0b3b7e2cee955ed72bdc4c5db5d5e91a1df5b7e1ba6e730f009bc13761896739851d47c41dbeeec9f13ce6a0d6a392510eabd5b099e914a9c0d0e8af2d1cddcc01ded4e8c2cb75b9a19571080c5f53dedbaa4eb6d232126f05859de9253ff77aa6ce2051193bc2634c67bfb0adbffbe6c6199a97f212f67bcf9374022cca1ceef97f93bbecd429cc8f0b7119c9e6b53bff2a14aa2139ce2f787f76ffec66868eb4cc570bb44a787625b96284bfa42ef933e2ba2d968b638c891f7f89fedd86f9d3a87b9f4537f8d19a3ab75ce34d000c429936250db8887f432a98858ea84c9a954444756030e64170921c8edc9dd58c2dd73943dc8ec88ecb301ff4260838b2118314e14b480434c5c7c1a1a0af6f17b21043d670db8823972ff6e055ebe5e8c088e85bc212f3b07d591d8ce6850acf087aaf785c597da9b06bee9c5fabae5c275c237a2ea3fa2fce89815b9936645edd354f56606770174fb0d7c5eb1753428490453e73f0f9aae8cd7885a29ab7b671a97a0b0a8c7e69f64cbb6783ae87bd39145c44b241490c72c5b03e15db7eb5f02e8c93efa6e0da69ef32d2755687bc7a6f36e84a41e4cd43ca8929d2507593d9ddad63a2e0a8899ed005e2422e415d5edd9141494086cba120dab848e0dd15cfdf9be500fb8602a4ea1cebbe965c2d5dac1b6776cea906993f8f3a3e4a643d19f9175a65e7d6bf1803030414db50126f43637293f802e1799ac07f6635bce1400a0a66deeb53ad736bd4c6f5bc89ea4eb371ed533bfeb94a19b753882d15f369a8d02e7ba37119ecff58bd66bea59463abfe0ad8ecdf43dbfc14d41f9caa281ec163cba1c0eaf664f911dc1b3e8a2da4cadae4c03fcfa916e39fb582d0b18e16d6cd1b6040f27f544192216549a7abfafa32086dd7e64727bc3d8a2835d24856c83947643d229f0c9909d776a7ce905e9c1c7c7dc5175f1dc3b41f16a69f890ee1e01cbb556dc9aa197386aef0ccd3042856e55dfd2528d622bc36c4913b2a3b3f4a962a614293b6873a104aaea924d1c3bb5116f484cd9a7894c78b08e9a90cdb672cc8decca286c29acd6d683261607d0fb992d32a544074a721a4e28d4a7838efe1530ff88aeb88860a99c11fc7d36390aed28607ff1c5e3a74ea5b504a1414d985904fa4e9153506b9628d4135a81987e0d5c755642ea32b678017a9c6b998c51176c0ebc0e9b834b643af11f1d74be6408405af5f20bf38357c0760a1cca0430d2e17e2be577979093c6224e8f6dd727e07b42f3abde5090f2fb93864988e8ae8c9d9482a0756ba5c9b9d8b062ee3a0082c2a538baef6811c23aa0082614a04ff546327de5a0fc273817239ca0e44de5d92cd97858ddb971cc30a73974aa88f2d5f12f7e733ad19f3449be08dbf4a36604494118c134e5a5dbfeb848f5b64c76e74c06fa492c7ece67742f2566dfb4f6c83671cd4e9a15864bd284129e702ab1f49d02f740e2c91449a8657144629f05dec24e891b299d682cffec1f9fd3389d224aa4b9feb7e0371ac1bdb3dc71d926eb918f8b47db7cc2d4d8fdd08b2e965e13aa81f444718c49155e964a7b6994a080c6180d2acd7ad99c80616a466ed1795046c235fe3fa926bfb71d3a8d9bffadf5c75d51d10fc753031e4a007662a521ef4167e47a94821b6c01682906749a69869bf2220168c1528f5cac0c11ed052fd22e6222b6fd2205a3de1dbdced1d18eb5dff64c7ec792cf5418fb3d2b32f5ce24befe537eee1cf869e186388e02b9221819b69d601499de8ad67377ab3b1143365c9b641b03117e37ae1efd175cbc7451ed4eb12dadb7bce40d0ef67cbb2da8d1b985643c676eda87ebdb124fd3564a903a310688623ec8c9cecbac03902893cb59a6ade0a7e513a041e34f8c97aebbdffd9914b9fe58d629eb0a757a610bc8a1d5e4e032800de41701de9c3f1d6c2a44f9792f1d251046551285d88b5b6dc4a550c1297e36c99bf566df498f194520be8ae07778db82127d0be79887efdec95bc7eb210d6e9d8489d6d5b471237c65a5fdaad3fea09f0d71e3bdb44b67d817936d9cf880a3c97134dfe4bd4427fe2d4db8e25456fc1489f06d3b8ce6922215a0f8780f71df818037a74b7f4be755dde233c2ca4798dfc5fb4095d9eac45d8c2c322ec58ab70724b75babaa3bddf2c32ca3207b43e95a2ad0d82f0c7f3562d5943576665e2971ab69a54f9e28fa75668b43cc47e69290f21148f4d64c44443e4f8ac597161fe152bdec575e5e9068c0de81498194a0cb885423c5c5ad0ffe4c05979dce3f826c0b3bd10ed593e69aa26c28b4ed64c326e2f4962e99bfd0ce373768624fc537542f10f1ed482010e87a1209e7ca74b2dc9053805171a817448c662cc53bb666d5b95961b19cff5bece0590bb48cee769aa214f9d158d09f971cb82a01db68bdb6f22b46420aacdaec17348eb93e1635526eec96d6bfddd9d9a2ce06d3abbc9287f5bc6a0bfe97f7044285065f3ed215b81a3089ae806aa6adebb3a26c57f0f5a8672257b34296565a73bbe977074ad108434a4bdfa2d080b03f804401c187e78d3c1b094c7b2084b2bcb6a4c67e8b69a2e6f65a215f5d43fb7bf25bbbdd88bc2eb25ea5cc895762967eb3869ca9266508481193031ac16a09db2082a993109c5c18b133fd40129bc0ebfb048f775de86d69249552a56f578be2387102a632ebf69cde02c3c7d0da94d0bbb4b84bd3c15bf0c91cc2db1ecefbe90956b708b98e3ad6fecb4a528ca7eff44174e676bddf2bd75a3b23dd423dcbdeb970b87074379b3f3527e155c481606267679c7d1274a89f0f36a4074a2d1a3911ecce3ccf7f175189f32b758876ad2f369f7cf47f75afb3b8c17cfff7c5129a2fb2204fc230d2b7aa5e935c5858d29f6282a705ce5d016a308f8f4f8b73c06e80a2eba2b55372c56e27669254b5e8ab16eeaa46f2a4c06e12c9eca3d23a6a735d38643ea7c1af3e8d328683cdd0417edcb1476d5d6ac2ff278465502b11d6cc4a7a65bcca169ea4792a697b6b1292ed3414a8ccff516b555c4d2dcfa643994d8b97ad6dc1d4704e8b26e841307ea72e56f665df33b597750614957f2d4bfb0b223fe3625420b636584a6da7486f48b616ce90578bdcf0ef3aa71e7997141c221999faef9ae6a8308a40791e78c50744f55a7998d3ba05e3efa89659ad3c0a7ade9524a5f2fa6c47213d0b7adc40b792101540e5d2625c17eb2a4d915f5acb7246c206a39e7690c4846732e5174ea6fe721efb8baae898de5951d8cb0b0713845bc16f0148708beed14b570da655474bbcbd2b8d4775407c36a440c2fd871ad57fb5a1b85f867d290aa6e6de0613bf672751ddd40114545f46bfc4ffbb04f0545c48ea89c5bd731385183538b29596222331587d3c6c1246218c5dc08440502c9598b3dbfe3e8e9bf129ad945a001de8808d7677d3e06cf3c78786e66c47ccdffbcf6afb901e8d771e720e5e99fb449e5c91c0a1ff5eb40b3400050c805e5c59436f3e973e3167f593a9c8d0bf08e2e25da7f463b3dd8709ca7ce1d9a6aac198033144b86791cdabcd464abe60666b46e4400d13370408ad1ed0025574ffc8281c190544266fa1c999d172c1c3ede69a7d5e60bb7900f2d67436b17d0e991a16d947332ab0b0e2f06ab4f2158fbcecbc65189e082681c3f2679ac00298e4109e301005445b465da74c69800c15a84ecba0b6624d403ae34ca41c4db985b62563f079b0034b5a25bd15c95f8f80b2ba926f557e89f584ccec8d28750b55bbf6eb472868a2362ecd8c216dd6adbf0f3f78ccdd85edbbfc26ed815f2c2116f410a23452789c41a5bfb844766e56155f8e203d03a4ffec5c6f3f72af61b7e88440cf24f518fa6a3c802893be4597445b30daf1d8d9f20cf984628aad14ca535113b8fa93894e61caa39770f1a2a2755af69242a34c72c5783b989a5469095fe97e5c7f88f49cb2e1acafd8c63d59ce3c09f6458fe3fadd218da57ce65341df1fba382f5b7fd4ffa5fdc615c3ab9c02face95e59eba0df16e9199f45dfd3808f39e777e785942162fd6e39e67a765c5eea6dd9162b9ec9018222c8b19b8e24cc7d052a31db4cf0061e4c0ef478fda4d462623ab0638d16177249cbb70ec0c688db12318d9f6a7ae53d804e66c1dc72da34e123498a880251f1918d88c47ad765667f13a277a4b5eabbc255f80ff9cc35168aeaaa0b0a2b61526e5f2957087c32182d95148c2215798d5b7c7c67d932b1b83f01ca58607d7cfc3fcf66fe7ff8f1231b595d907692709b16ee74bb04e0b86ef75b46840311965dde140cb0c76d54c619c4639e0b9b04f72d05f8f80182a7a84ccd804b9102a5fe4d7743b1c2d8d3bbe2f7104c9f356346d22afe580018daec1ce89816427db12cb70dbb2c5bac62f76eec9f453ea25b319cfe56ad8c6cd647cf825f29546a108dc351b3cd01b0257cb59fc94f93522eaeb2e4c82e4f1dffa3225526355ca7a22b4659652c8f64ae728bd68c856ecb1df79c96edff62009ba0df40ea3c5c46504c088272145f582da6d042bd6e4440eb45fe09c3961833d01c01f98bf9a0fb8bb4abb7aef19cf47ecd3d70a1c87f1c6353ddebe62dd5e0b3efa55a2a51c255a07d39fda323c2fc9906a4149559afb2a0f99ef2b8fd434d91e618df1f33d86c6d5b5dc9188afa8a24e17b5b7d7c3bc66f77a9950954fabf732cd89360e8032d2e78fc804a1c3c532d843333e64fb275c0751f61beae4aa7e45b91c385a219623ba113496b3b2719cf52e07fb5c51862de0feb19a1c54f6c64d6bae2b0a252c9b0651196c499a4b467fe448d51fc3f98bec06ca80b3cea7878c08331fc698086d6d3e6e61a11a6a675210f1cabb76f3323de5fd955664ce281f8244bdd8557896d1bd9f401404d14977f5fedac1943b78c87dbeb7292e38a7211032b54e0c4fcfcf99be0a298591537296acde3674eb7455e7a3d022477b08c33a97cd01dd0e48da66bcec91c6f7c80c3c2f5a1a80160b2b5a05e6bdf0d82409ae39aeb8f7061fe965a1b6660cb601afe4f0cb7731ebc25ba8afd536e4af55bc6d70dae4e477a3e9288c7c8266e82243cfc8ec4d3aa27850c07fbe07b38dec096f81faa85a803995d5f96061deff44b03b2281b718787abd5b2ae90bccde238bc8327d08620c82fa5f79201865a1f0f53b9a41e9138955075cb17fbdb011d5e48d60d0be45fbe89fe000a88c99b5c7fadcf49bdfc6070ccf35a0d102f34957aab0e17cfd783fe54ffe8599362719d69c1e3c3efcbc1421d87f86ed04b505bda294f32271ab2b1666ee9dec3589d3a31521b1bde3745b714aeef048311331bf3cc18b8f6b134e83836ad65c9e6fdde756221df6aff7f73a02cd59389f55c6e867df27881e44810ca3937989aec0701e299dd34ad2b008072c6a48ac4fc0497c89ae73e7037d3a500524b0f68e25575891aff18ebc0891b4f1cc0609ca66ea5034d8b0c2215fcae82b2296cc7e492cee1a7e0d2f63b7e88ad934220f897f1822764ba8d67562fae2def6000bf3c948b11321e0473dafc847785f34fd9fa0358446a104097715243663d95d46bde6955b3b7b9a3244b38c3eaf65f1368db54871d06ed73fbf53b31741c3cc18604b1d15d9595a0124a91beeab0270bbf75d40e0660a9c009206e821e28f0a766a25915fdcba64b6474401e0c4daf14e7a363a6c4f79fca10bec212ec23c120ad7891e83bdd173403c6814e4a3c62698c8602d1fff04987a5e1394dd9c5291ffdd9edd4dfb350e6e0ee7865421c09eee6c20baacdb433bc8e32ccfd2fa98b6d5a8217ead88f8a9cb7045eb8b49c0aff90a4ffebf461577e77047c1f2846645115177b3bc0533959adbed55c1b3b010e272ab2b35ee9be447e82a39308cdf97888b4cdc64a478f229dbe590d3394e64c37286b0e7c1a7e149f4e7353143d611e40f037f6d9b539c9c95dcccc0db6966cd59ee1133a2acafa8c8b91a560e509f28ddfbaf7fae9ffce64c13f1feaf6e2328bec1eb5f725222bda6051727847abb703307d5e68ce9c38895ce5142af7cc00a0fc988ded3c22cceee95b1ceaf133759b11cfe9694c41e21775dd11b7a94e403a4bd375f4ceef24cb814785ce23bd80f143a511435b4c523a36bb3fbfb293b7a31ce6359305d5591ad1b39347a2cd3d8689f11ebaabe458bd8aa37fd15f9ee8ccf32672867667f5516b8df51179d7f70aa10002309db8439e044e296b581725235b346741b92c91408296aafe1a7473e070d13540f99670b5bc279d8f0a29a78fcf51f03cbca1bd7f1374efcc8b7fd29555aea79403b84c04874426c1d0a4cdd2a442bf24ea327452fd7fff2bffd1f216456055cc677384cf784e131173c2b29d9a8e6127d2ac21da1927e04ceaaf5e1320a5047e50e38d29d063395fcc51f6b1f17de56b32826c9febf03adef29add632879cd1de83d63550335df9eaa4838c3bf549e3cb9bd3526e31cc395f07574cdcbaf1b739126f063dbbea456a4b2dbdb56dcb79287c0e5e057707bce9bd8aa4c0f8b2dc874d03b880006047c9e136d31062c88e4866f5bed4b4322f35039fd6db1778f69e8cf2daa9525d3002d225617fa08b6a59fc26ca1ae9c5d812f923664ff432d6816d6d5397443774a11b76cc5900c338c1148acf5807e192d3bc92638cea9e3a8a4c4c9543651435ce6cb129b38f73768d74fc4e8ac09e0aa92b23b60928349d2b388bda884106df304ff7662c8ff9327c495dac12bf7ff8dc4ecbd152019da78ee27252a40c80a6d9b897d69508de1c107a00e317e505cd7c7363ed1bde94888d3343418c88aeb3805c49facf23870e55e2ac5923ae9bbb4a9534cc4feaf4f840b257e0e140628e0a1eb12d4e158606d837fed5099b1641649eacb26cd41715595c0331c3d3810cf46d5839984d39c90a583335775ade49e073373b3539faeb064c1c23b48f765d8546ff6366d75802e495e5c559419522f634dccb839fc3c13b3b3715794aa51ef7804aa242fe75bf638cfd30db4d12d298d0d608b89a2a69c13dbbe34fbf566258727894d1723bc80f5b5dc42801206831a0a9ed2ac801ccf4a123b8af258afef71ec7cb6578b7a360b4e884bf41f85bd56abb93969d22aded71ffae6fbee1c8a0f4c95ef9b90f6c32ba5f0110fbc8a887b7232aec0ef82bf9d113bcd6208a0e892c9eb23281ad5c636d95304fe5d30120c000009bd56689f8e25cbd1bc2c33cbef6169df59026c2f05f120a8fa71bb73ab2a47025de9c4751dab59a5e6bd1eb05af7687ba61fdb56c6c2d654f025ccdf07a3103440b3440b95f3e4a919b4e29232b4d0e535ac9304da4e3a0ad38c9952e29e3e12f8b860523c6356cb78f3f1ebbb64d88b291bde277563cabf9c29904d86b972c54d519fcb9579cabb5a70bcf93ee7d1a171b67347e424a65123f3628be1e000668fa453047274b84e0fc0f32a30cd3ea9b4a0269bc56a21a7d33706ad3eea17fc541e76dffa483c440e768da92354eb0784066811108beb1166e238000aed3edfa1113edfbc1362ce4279f03459373c181ab58ce46707dd0903c3bdf5c7c2beaa485912fc48e4355f74258f506a8ae6b0ba0815857931e0018c1b2f61b29a7352780d0f55a7dfd10e266cea3cd64227df1b299456ec24f891be7c664dd2025ae27719da258f09e21eccfa8e773b4c975d6d22d4bc385b223520d9ab1650984fe49b00f75d537d9575646a9afab0e63da7391154560c9f1cc785355db38d0195d7706e1082d9335a5eaf85c444cbd7c9a6d95ee4472d1423dca90fbd3908896449578dd9bad3a80cdae4760680009980dccac86b4be0c7c301853bd6e3c3c685028cfaace23f8c8599f3e697c4ef8fe23071cf921751f4149a10462c0538626f26105407f99681a1c0b801af6c9cb9d1c814ee3ba5c3a029d58bf0df4c7c1289fa3847dbae8fd8af40bebba653a4388d669dd9f20414052e1bb0218a662b5370d90e2fc397f97f978c313d087983e0a1bd1c3247f1601157ddd7a8bdec309829c820a0878e9f3d77a67dc194ae73a7eaa0dee74fb4bad77afa66db3e756ccb89eaa5ea8d3acacfd6b3c1b91fcdf35d297c5e5ff01cb30ff081c34688a000c5bef7d0270fc3edab72f0b51f361f8818c0b6cfd6393d88347fe5e75191b0dcaa9bb3b4d615cb76107de50aa083dce0a9933e9187fc4b6aca66e0bf62e3bbb91798ae231d3ca218ad8ed5af8c9f326aa522e59efce8c0e58b832319820c115594977ba579e5c033a479fba01b00906ea6a74a853172b54a2cbc7a0f3fbd71d363c494ab2e6c6bcc38fa5f354fe49a7791b34e5255455b496c6a9078b450749d1452380c109b4d72bb9fd3bc460394e3e7b7c7c035210e80ba161341edce3e7517bf1848c7f3747a9076aff2ed99d49c96dad09393adc8a934d0b9f59187f5b0f583b0cc6eb0f72bae3a18a711f134a236f166a62b39748af402beb3b1afdd47bd32d52faece7fa2ba96fee708a65c62ffe79c84fe3d947d2e46948d17e98c8b47bcc86643089f701c07be60678079e6dc6713b59246a713dd549f92409ade4959c0175db270d28989c81fd166cea917f03bac33be9d8155dbc6cdde69551020a499facf39ba2bff227a6ac578b70035a56361e3075fa4b036e218af2ee2d3442bf84c6b7bf1ca8148d99f76ec7ffcc88802327e1c6cf2b6c630224910015834060e760ebfbb2e0e8d239628d144a06a62792923416847332e3fc874321963a42dc045dec395aed0fa14ea09a8c440557938a615c7c4a5dd6c6c65e61026e700023260b8b9aa56c75c2a570719306131783910c27c4cd3d2368d47e34a5a61707ff2112f5ab8339933f66fc05202fac75ff988a65d5702a77f6a5e0bdafd65b80fcf1636cf2a4453166080eeea69bdb8801713f53a3a14d1f29e55fbb57532104cc85c306ecbab88405c489405ca53a03d86310c1684b3c3a008943f02420babcb8a36e3286916106dadc764071327d821bb86c2306bd5ad457dc5ae647cfd04270b5668dac8c831dc13215d907045524328502c73d2ba0b4624bcb966337c52a96575031f986165a17a652a0e152a0b3f2f2806744549d7c5a4fae1807c0e5df8fb4cd0b944e61633c6c14272dc595e7c3a91aeec65ed13bffc05a043c1418ee27dd2f1f293697560cb4b93252a298c2d5854799562f05a637f5c6fafb0b38c8e6920b05ce2c36102455306aead07492e86e40ba86d2b76974bbe9dcb5c9d6938d146ebd1acca509fe5fc3cbccfb2c7c56fe9d392a429b7be10d6c02ceced91ef14d9ad8a13358559477b32d6e4a1c1bbe0111b4179f11084e5b77c81e1a5b1b5d5da25c0ae74ce4c284df0ee8bc32fda11ca01fa1638d421da3b360c45238288dc54f8a6f19827722e0a580ad52bb050bab2904fbb84253de1c4507d1228298b5a1b62a38d3b900879dfbbb61105c35ba20275b9f1f497ac81a805cbef01110ed7f3cfb2d4a3e6a53425da945e4fc8b0bc68a3ff6d7dd73a7e46be18b55aca89d5139f2054595614ed7c4bac68b58f90851401b711e4b92c4c58b4254e72f9a8f455964dd5ed671af539f020cf4086ab231aba673da4b9a53f5a2f718624ca1af065981bbaa08888f797e173fb2502f630ad0331cdaf788f63e517ba7c7322e76f052e23951b46e4a08b4b6b2baf81ecc825","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"12345678901234567890123456789012"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
