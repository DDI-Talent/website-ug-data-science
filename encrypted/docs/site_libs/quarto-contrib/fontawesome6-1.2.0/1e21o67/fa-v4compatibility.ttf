<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe12efa3cfe4d52057ee3cd8a40b0accbd33e382094d72ec366785c2a6452baab61559cf01079aa51755127bc86699377566120bc56fe388cb344e41cfc1d2953cf79d5322b463ec0617b49f6eb2b3990803221e9ab9950aa334c39818156ef003ada66d8b5e04ff2b9242a80904b803b1597d57257912bb989ba13a286cb2a7b64a97590243248a80e0da420378db0a9da4bc954718383a7f69dd051c334a222d33cdd4ea6a2f097a241ae539ab72f4889ad272ef4715160ba7b22c8489075946e2e48b658a30200b6f7a56f53034a0eb7dfd8ac25ec5c40cef1af419c7b644ea7526de4903ca2b6f370d6583eca8904dfd16351c0c4852ef3bb8b5140816ce3b93dfb4c5acaaab2c737b95ecce1f21260208d293f174b6277bf89373f22289ba77835eb88dbed71afcd68665bade00833951deaf843e0d2147290beb2cacc0803a93f560847855b631ab8c0914fa2d146adc1cfbd748e139383d2ca350ffd0b2a72f8c01b2ca9741d4200b393422398c6de0dac65051001988a7fda9eb1df225ad5eee4c9eb5e3b42ebb11e15256bac02cf753031edd9f4a281eeabd2e3c9cf711aa51c23d72d929dcf4280d99718c42752d6224bb4d07c45aaf326028c01e890435a662e8bc42d4a7dbf0da7d21c62088d03f277cf3f5bb9518b9429b399ee43d7ee29bb0b8449526c7e663856c8411af9956caefa51388c0ecaa54837ac6e2251ab95cdbcbf430c4cdc474a3a4007f0461829bad8a302913553e4b262fdad36551cf6df67fd35073154ec1e2f8958654fe16ef4610bf5d72f0151257d12b527d5bcf6e355c0a70f648ffecd0b2797e3a5c9f441114ba86fd82a92f2756cc93de7589a568cdaad29935a2a5aa03a0ecd07a72b8388b95969e55ed5434722cc954a978daf9f079f07c42f32602268068667bb87d5685b805241bce6e76073395c804ba976f40446cb396bdcdb511e01492e1a084141d3fd45c6efdf196e6ea283dffb7dc15f13e25ff526bad71ad91e82e36631d3b3fe13790953282a94716a76067e3a1a33577ad60e0a0aefcf8da99bec7039472613bb8a391320fd21de3008545882d05d73bf6548b8d4f38040950b7ec4e4501cfe8ac28d8ee05f4db6556da965af95010d141e501f5484e64865b0565ebc535e7bc44eaa2872cfb3e70f4b1ea96d3fd2ff25a824693532f380f411aefc94cdb3e5f561aa3702fd935cd8055db10a3ed84c7bdc43bbcd17d03e87473faa355e2b36f899d2f51fe38649e97f4db3676197b66b9f5044cd7a7ef9244ef7251317418196106293e61432726959e1e337f6a2eaa3f6d6477b658135b0f130706128faaed5a56c874b621adda231918c3662f3de62d37bc00e9ce2f62bbfbf9d92975d0ed3770ee64cabdeaa8e28693b3ca36c04ecb3752bc43535ff37afd24c4fbe8d1d9691468bb47aaa39d8c494e15c3a2b5cdbd08dac85c9195ac2e06ba12aa2b2628476604ecaf6b7e5b73cd6b40d2ae05e17f10c35fa6577ec80e4e60fea1967ac778e19a1288141be81bd7242576eb3189dbc8c76a86a9f6c279026a595f01b1b737cfccc6907361b5d4298e9f563202b6e9f3666d24ad8db1f0f8fe2ca4e176c1704aa673a67be833528f2430ff15dff2825d8797958e071edc2f92abd04cc599f95374fdd59d1c474b0c05162bb78ba3cf3b04f2460422cce81fbb17f6a3eda757fd18128598ef6c978cb6295ac2dc225f8ca9ca28dabe4bb567b50341981cf77bbcc08e620c150f7439941dd613d6df8f5c792f81e08f4be2908f897a10db6f01a3af8f58458278a58bb97c0ffdaca6bccbe156cb96d43ef0c338373eadb743b3a4878e068eb487bc719e67df3439773821eae3b9be3b88866745f55217c37e763f89e109691223d6bcf584af0bfa7cfb65b40cdc322f99147a0d78609a2d0628fef7501a63cbe6a6f1d325bb8926583489b21fab6b9a1408365ad09b26e429a922005b66bf196d828fd3e5746bb69043baf2557f54f615a021675d399e46627aec15905db68ffb0f901747b6978afda62337e6215657ec1ce3c6ec13a8b825cb92d1399e21ea3c19a64d766d66fb1a970a263b47466a7954b2053144b2b6116eed816b200d33da2b6987cef6f10387a3898aac1e21ff6604833ec4567d113bf357b437672e75c82e4988a110d6e4ca55280b3541c62c300757da789248fd53bb35afd07257a03747fa0ee21b9507b5335f9bfda582cfaa00e53b7dc6abef6434629d09ae211daf943fdf40ae489e6c520505cc867997a1e1d5688f27896a33e59d4c436c3c3094b13820cb22eb4fdf0c5909b8c2205e193fd5fbb351f99ceeb61b9b72c81f3d9db18998bfeea60d34ed3135fc113cf7e602c9fab7834032e87f716d2f130ad315f0a8d2baecd9d2405ec683fbe27dfb8ff89d33e611813adc8a414c504315a8879812e7c5d651df67b5e86d18476811118ff8656e370d253421bcd20df0aa571557e612166bf00e5c09396c89b513edeff3e00e2329f8073f3bec959d12f15576a9e9af122d3fa21225b74f54629e1ab6bfa97f12a32f96a202c13d458703b81062d9e12aec2d031b4c1ead76c8507328c494b7d4747dab26234945ad88bc28b62202c1a978c2c5789ff3348dd352126610c7e379a2a0125e8e4ab404f70895780bc19e25cf0168cde37523696c1646c63e634db76120a249de5f180fc66b7710775bc58d6a6e4464d0a9c110827f74e92e63b2ee969b633bd501235d1c5d3723aeeec7b20e8b21399ff5e84f7a4f3b63d89c98a98256fc85844622f8fa4154c43879cfb9c0b0ecff33f8d628bdb8a2835d4f094325894e5ee6f36e64fb7c8c129324d578e2cb2f120f797e57d1664f4d3b6c8841c78ce5bdad71cd4727a7f2a4e4fbc62337c43cfd5efbcc84adbef91f1cd043e4d9ce319597fa5223cb7227be1d93c296ae9528d8492ed515cfdc7f9cbf3faf4e38b65ba7e2bc9247af81c42993187567b78616e6c4bdb6fb860ffdc635ed24d9b756d67a030ca4ca1ba73d3dc07ff32a8f2bc3b54dd6ed094543e6cc4759f111d30b9e6951fcf5bbf56249ae54b93b35052a9d700bcf4338efcf815bfc845c1940b01257c3a36a9ec217bc58098e12bbd823d420f5894ad302497f69daeeeed7e9aff8457d476d645eb7e647c73c1110cbafe0fd7c3d341e4eb9b72548befddd50be2e3ee520591ad8922687b382208a5ddab1507eea4aeb666e3ba4725e039ba03a04b72e553e94d5e8522e2a4600ea1ec12ce97b40cf5d0cc874762e61cf565f309ba6269ffdd19ccb6197448c68fede650dcf7b66172b55707aeec3cc80f5110437b5d5c0bf2f9fdfef723db0f183c94dcc3a8f8100cc098ac38894039a95127fbc29294960221465ef9073e791529ba1dc03ca933e5a1dc3e923074482c2b5cc81618bc17e2427ef6e4f30aa1867cce84d25c6ee7cde1b7ff390ea0b85c99ab84187799ab6a81a82a8ad89ab22d447d3bf9d4523adf8942f3c9cec63dfa9feafa1bc64079ab60b91de63c07406c00114247496af425c5b9ab26a0c9130da825d38d306b7f7d1db99c89a23939bfcb5fc6ec9a85128939227b9a020e924e64118a5eba2b15e94aaade90b9e5823ea2904a3a6789b965e02001190583cb427790e4371e1144892947dd45acf8694e0c665ea264175f3da8684da822bbd432cb6130ee6756c560ad8202460c63e9b973b9a87cee50395f5a003bc34ff5f2e7470fe40310e83dda2427803f1e7ffcd36e585d9eae64b5884bec6725a8930a0b55bc4b10e9f705fc3c3627c200a5202faa53576457012da8f0bb1badbee18094803383c13044f02c1ee3bc96e56ad157e940899e3f92062b65588fc9dacc1d03c39f865194f2aa7609107d9d78499a274d64a13a56a01dc6ca82bcad4522684aaaf967b8c2fda482acaf46dfecd3e3ee08a69cb1618f16c86d7fddbbb53e593a298f5a16ff1d7b73c6ffd6b77b6a2d1ccffcd38ae8a7190855e217ef15635f18003e4129f604aa5ad05f0023c46d2f196a979cf4df647016d7f0d34f5c5997e16317e7fef9b080737a35c5d5a67a44bada50105e02bd6eda6f24a8a2bf77b0500d4d3adeadf61c6ec2195f3b5fc5d65d9e19c29f1497c7057b5c0f63f5da37bdae681f29091ea23885c065720c8f4fedccbb3ae9b080a0be7b748594930912230bcc47df125f6b611fa38ab0061d0baa4972c0ac578279d819b9d77aa3abc1f3c8fb50dfc01fd8044a7c30e6443a4af6eec387064ee37e0fae6ca5d753e904fda018b8f91cfbcbb8684a6451253e8158f43fc75936662e6158399cf22687e6bf7d99896e5a03b5a6c8d4b4eaa86baa5c3621c9c48fecee1d3ef44e3b2a3d7b0a302ac60431e4037ad0a0206980ec4bb9cf13458615886ab2dfc5de723c2447b384a901ec3b0fa64d836c75736c0d5880ed9bb3b6556ff5cf4050643be75944a977311d887a12417b9a5cc24b7c45fdad2cd5fb2ae11e49e202c4109f18dd2ed0df6703bff3016aab66f37eac905e880d0fee3f9a02552a61494c700c17e12fb828caf6b68f67e0fcc42ba1b0cc77605d963932390be0af952e3b9297b35293f58a41f121081be6db33c92ea0e3d51d54ef25a243929261ed115f2b26fcd560f39ea2b67322865790aedc7647ab9c2537f8acb3e29ff74afa927263d7395cd45e6491c229588e8a09ad425e826c06eaf9b79de973f4477d767aa0bce151c333c05139097e845ea02cb67ee9dc5efd26aecb81c2f66091b89b828cada233d6a2dccf52c67541376df7248d0cdce41c0907f727fb778ffe717a5049dd6363b0fb70c0a54799358aeef14c2016779ce3450737c4ee4c2915cb398cbf8af1242d8e0d4c8243c2bbc5331ed49467262dcdffd20aa7b2952be4c447dee94d2661bcf8fc07356b439e9e11b1588d0fbd442509d5842eaa47ef966bcdec3a1d1588b9f5aaace298d2181ab0c499f89dc2e69b96a100374bb5ec29c40f838466f405a1cb653dcae1c89122b767681315ab6ebddc962b15840878e9b5b23544a09ae3a0b8145462d52bc9cdb798a22e5269f134712b78208870508417f5326306919cfef65cc74edee9ba13290476f74402d293de8daf536c3456f05210b60e6a4bb3d4fbe598c613ea2965faed63259623ad355324251b5eafb7de5577e235e9b4dedbc51b064eedf8e5dfc0d422e9f5d1e8befca994386477358b50b760b9af49da20c45ddc56cd96122f91e815f5dbdd062223fe4c68b68e98fd7eb7af9be81dca28074f5076d08a7d19fe339d69e282cada681a0db7c6494c23dc5ff9baf484c28a4d237d521c9d7c58cf101685ec9dc380ede2ffbeff05ac9ba9e2f2f8bd70df9b98d3e58532422c65038d432c69374a3902d90634e06451c7e8a3a8a408eb86cb344e0834d67019a7fbe83abf49f18d0f3d55af591545b63a906ebb43a55bec2cff7adea45feeb046a9e044bfd387ea5d5b798de59c279326dc20763a0c58ce572c5d8f37dd6c364af7574cd12b697e9a8b1b292eccdd75bd09c4e3c29c62c8c795476423fe149ee4142b82489414a23d30e07351247fa0addd7d5fef7098077b7343124402f0eef059cf00f3f64ec88f35f30c42773280c81497fb1762f9712c0078b990f88246c55e2111981e124d064311855e9b64635934c2ea23355552b2989ead8f91e85f7b9fda29350eec0c02c6d75ecb6a0fa585c67145e4c2abaeb26b2a81a76337be31d383a0a9a6e50a8f8303ad668319af207453285d7f226bea6e6aa8c8868f64d03773520351c21ae04fb21d6516a222c7ab844ff089db746e9f8605cffd7b5481ecab077a85b61ba95ca5377454f044ce5487de4ee69d91b187ee81e057b7c7c2969787d05580c9d89938fc618780051b5c53552d827ec66fb7e943b4fe6dba0febdb1b7591b6aaba6485839937ace35b5bfc6d3299f6acaa7fed436e052793cee812a249a03c7971454b8b63d61b97836e0d16edf44269d802e6a59b518e066840927f468d09f08657aa9d55f9de972f3e24f6040f841a925e272b5e62c49de903728a017b8f5561e2f66f8ca5843a8d675cd45d9bad61c2c6e3353b6049f1877f46a82d0cf0a38867db9d6ef4f0e6f32b30b45c6c60142127981718e2e24d4a653ea6f5cadeec6be8ebd396491d93c272edea1cb085925dcfa32722c49a33e424f7ee4e0191de2b529f901c067fb7586299680b0c5c069a42405162564afa8762e47a09b8f4a21fcea80f7e8925b071dadea05e5376f21d0cac394bbceecd2ed3e5780676f8a785bf8b530f0133114295cfc48a01946c291bf9f8d9d19619e903d47667f0b910ee52874fa743f7837e7cba715451d8ae8d3b3d3840fa41479a104c01c42343b1d0d7c1917d3a91bffeaf91d90574a4006bbd32a4016b37f72384f27aad450632839ed0207adbe7ef47d443d89c460bf6114e3bed03ceabcf7276caf69965189cb1eb393651e0a4616a2534eadd39f4d8d4b7c34a446d4e9378063503c77eb1d71b5c4158dcfdbbf5d0355bdf84e48e5b1984ae1a853808720d0e6837b4fecb1932568ef45b8c329e5155a2eeb153fb0f91545635b3bca5f647818ab1a4e8228410e3225c98ce0c4d6ffc0e0d540c811ffaabc824d34df2a0af29d01cc15dbd8dab1abbb7f03aafab1aba386f76b13d8bd0ac35c32322b20f7812b9126101a45c9ffda1db8ce827c4461960cae9e7f93fc4da1d1c99ad5a8637ffdbe27bd3e90eb742e14648ea81ca98b1a65aca90ddb1766dcf7dcccb7b325aa02b05102e8f04bbbd84286341b0dff5f9164e3fe1123de5777ad6e4b641baeb1b1f58639d00b0c68a171c9da542ba83fc7e20de3246a70a460f8f78d6c600b259c70d7dec9693bee67f296dc5fc073598f56d051c5fac20493c36c1cdd00cf8555ca6b3638140098edf050689213faf99397ff6a3f7fbce96e2fcc7ac5d67d0dfdda51d2875cc9a6a5c56cd4848875dffa34d38d935abebd79970b47b0e770001c22e60ffbf48292ad7ca97d17f1905e48072db0e17365fb31159e7b36869c5a0e0f22ac78141e0bd410a48aa6ea7ef7ebc5722536e375f58402c594056aa89b6d58fb2c43a38b43599a120e4b3d7a11365cecd66a6b94f03b9995ad85149ce0d86d894a4c96f54e1995d89b7ec084b9c5f57ebc69ea5c0d3d3423d77bbe450d58189b4b6093cdb1c49e0200bbaa3b2bbbf2a2fb433696c380d6d7a280c0036077a3cc0fefd1c5b28b269919f208a1d081c33434c1a66e5ca2b1db30ab2af42410b0a32b0d6ea51d4e9d91e431f9fd8ae19eb2d249fe5b2d86ccf7a3ac5eadd5db11ab83d0030d3e0af8faffa808ce1e02475558a6d3d8facdeca7b77e447ae664264cbd03609f3ec9da80c9ad11fa54870fa9df805e5f30864e7491f622c9e56bfa370420ed9fd8acfcb4f6d2465cd0f7c3ab2f438912837f31d475b7a4cc4086019e6d9b76255bb235047c09d53c57a29fae580c8337c27af24bd87adb6308694fd4647409862b4a7537568a41630479bf625aadf27f7ebe371770361fd16eedf2655b2065a4f69dc51107dfe089705eded0221d178831975080fb8c8b13bdb4d076987e0e8e5f75b3624d96683724fdb09c42508acb971e67cace4aede21546d33912ff47166702d6177a04e5ab667cfde9c7324f1145eaea3fb15d401c363a4b5b20617140d15263041b149a1ca54b65fffd9ca0f6c9d1d6db8e1050f2b2d46aad520c758b801b028b290a95ab6386270d746dcb3bc1f84bd78ecd82165a8fab42bc9ed0a79d424f105a8e32d75fa3fd3e1e5fe45cbf691f605ec3cb6e6bbf9aedd0f9496544567502ea8e17cfcdb03b5a95353a643d2de6fedad9ce4628316b2d3a3ae07850a2b3d24ee7fc81f6649cab5398d577bb9f754abb97bcffd3eebf303266d2de2e2e037f41d0caf4c3621d00c512708d6f6d0a28355ce109078c8acc79e13283ccb79d7980517c0abee9407db356f3a64486f73f32df218d9bdc94c06f6359937b4cc6f50305071f9ce8744cda19eb80da3805c1a2f5706815b92144f91cbddeee347f8c51aed06f678ce37ee64d4fd4cad8a0ed1f04424e4c4f1f5e391da222f2406bf131052c234de59a4bce3085d3e2781d7a2928711d3e29b9c1937e7bc7205f691c61f82ca00cf7b0767d6bd8a934632794fd110a547552a296e57b8f2b476ad931625f060427d007434662f2855a59c07864e8f69d45af52bd673089049b9e61d406ea62e172a92cd0f0dc69309789aa712a113ae9260f448a487a1fae70f4b23aa9845cf8fc3a0529709c534db000bf360541ff48d68a46eecc43a0ada222a9ceeae58ddef22634fc41d439fcccd78920e28069c635d1909dcb99261978bf6579b116ba48b125ea0d9de9e0c063fa0cdfd5400303ac3f1ee3d7dec9e5e608260fdfaee0b13bd85279f511e60b2c52cfa7779ff0e17f1df46a91f4ec5b48d5b8f1e1670ed6dc8bed1270b5a06f4b0e2f7fb5f1b1bb508bf57e9f52988f601a0db65ad1484a96d1061900af66b9b649dddeb4a4aec20d30645aadad0618c39adb18d10922af0cdad7f697f7e2d19dac991d72cdf43d6f1239748d08b14622e5e79b196d831bbe98cef78879742c619e7528d59a6a6a3cb7af3616ee608083e73c056e5d470d90753a6d3f9596b4142e75827546ddfdfb2c06cc83d7f009ec689b5e2778a6dd85e289b5100b9aa436df46179c5e639790ee1e9ac5278cc6a68e64e38fb3fe70d466ca7990cbaf4a626f348d9c42521626bd464f52a9bfea04d102c8932b1cf302531d1fb003498e97593747615244d80da6abca08720dab537c6fd874ac77939ae7c4cec351bb7e6c589129930e34887c71d3489d78a2934fc239b7d8f557f089811e6902944a7089eefa4bf83fbd4f56d200dd6c6ace3cdf1ab57342ac2cb97c92c38e2a97d66d05f349d5487018837e8aaecf75c60b34e7ecadc39735b768d030138f31cf1aa0e06862cb49e743873ec674783464c24e0e790d2c8a55fb64c2b45ed5c83c693142e0e1ca2a09b5a87f202d8da6d6a024a8d555e9fbdd10e4fcf155fb015d59e2237d702c13a91f1c3f29bdaff9792ab86cc3185f35c99e6f09851502aca6214ae782c497f8d0ec6169cbcffae91a04829115d91a71f2d3a1536801d1fe133967fc4a166063afec0559c63bf8622acec0bd8d18976e3430f25eab4ddbee7e0532f2823610c542fc4206948d00622256d0d6db73206a89d1d75db537be9b04d1ade16bd5714881e5ac960b1b27ab6a3c438a34bf5e640e0bfa6bbb9f3b099d9138664409e0fd8a1f4c8d2475278c6041051d13b9cfe9a3727b5de77b3d435372fc1be2d3ebbde5803de0b6c72a96a200ecb2475862e659e5a820d6a53b93f9c50eca8f3a7fda741c3d810e27c93ae9c429180b3bedc1b29b2a4ca4cd9c7851150170da11eee22dacd47f222daf106246bd91da28b5cb4264e5ea77b700636449e4e7e44373661ee9dd40678574d5fc7a7bab7ef5fcd658fefbedc979d12eba309e07a16d95c64e5db57efb628843d5e48c4a63d2ececc6f435041e3d696d63c74a768d75e14d0537c7653744d406537605c5adaeb364eb65c328a27c3aec5488f976694e40e091f9a839fd227c45bf40f6cf47208468a04a7082e3cac5d2d2aa2bbcd4a5807947bac5ae095e53c956794ec5946820c8f9df635eb5f2c0cb531f67ddebdc82844669190d68c95e423c0e4cbdd04d7db2557b79b0955cc91fe1103caafd3b3d350d4689fd048b8c1727d0374e06475b985538b36d8de2580b61bfd496749fe74ca9eb91b749f9768b376a3a3153aa0af5d0e9a690e1e819b065f11bda0fc4a818ddd95a73a7c0e3a5f4706b5be10c49a66359fc7336eb95842d61a293a81c3ecd51105806f78ade8bdd76728150f132c1ef74f16e38edbf8a05c4675488607ca3dd5b71d480727201c6579a88d8c20f1347dcf07ade2601eec2043d0ace6a044be947395227e27935abf557e9f5347fc0f9b94a59c20982e906363aa007a19a9f618293f19677b2b4d67a6db014f55d02d130344ff4af44694238706a70205d6320879adb0d86675f2d478b5527b2fe2e7d2861db7a1fffac3a11295ad6078eda60af6ce6484971cf545a6c19c7656425d31ee2bacc6ed705e2f4b44cf3dbab2220a5e9cd8f3e5d1b78787aef5ddcbcf39fb4ff546ecf267cf148445041fe2950b94011706fc5f5c9a07c2204d4b8f6e62d449cd076494e7a6d8c17554462fcd15160f46fedc37d1970c161c245022471a979b0caf3215caffefcff9a5c46893b2ff8067933295280ce20a98c099b5fdffb28404f4a86b3eee46c703a72c8c021fc32aa8f762e516c56d504d8c6ab14abbc7023196248b33982fdbc64a56a0056c528b56907ec4fa76fb50e65e75d6f2c1a73d2e0924ffc98a151c067388322bfde10e37f1462fa9c6cf4951ffaa0144c7155aebb9399a83c63773b720aed5c97054221a6bebdf668ce2ed8eeef4abcb43f26376391625561995c5653da5742940ede2f27e3e428d5b6ae690996f1bb168b17015754d74ad42f623dc3671e31f40823da3d01067864bb33dcbac2521d8415b03d66767d977b273817474c1cf333cabcded915509e483e62e926c5f82d7fdc70addeed823c689e3d0d8cb941ab6356f392ec6b581f2ef616ee3741d2d6238f0b483901032d80bc791eddb3af7f76b312826d80c47134ce10b20aee0b80e5f66c5052a98a252fc3192feb47d810fc1856338770a1c5d57636e5057a9764529ac8f94e51f4649cc447770e20128603d7e398f7351c82d9f7064337a411564d7741a612f63f0ccfc7db36a7386051774752cb73b5aca67518f606a049b7604318d89eb06af9bbed571e700717346bbf6356ed11876a38f5a3adfae5c93d8bd2fc32db3b58af174e88f1790680a32d1a641c3523548207d9ce9f3469bb4537a488267335011a9d12375bacae3feade66681262916426903f69fcecccfdedd1676b592ac70bad94f1e1eaa0a5b07260db50f26c44949ca4b8dbe5f9164759e687555deb32a6a6fc8d664c19cb47326021461df8b7f3e52bac476855914c645d8f5f3b1913d490b727e64aac7385bbd11f466b1cab9262dab20f638e8a7aed85f97ca41471a8a2f82e2e38f4ac1f16bafed7eaa7dc57e9457c008a83463bbcf170654f45e9b2603c26daba794a27b609b35d2c212d5afaf9f3720478a11081c0ec81bcd40d0a8bb2f96c47251ab25b6f464714d86238bc600690fee0be3c2895193d8986cade088d6ab76ab6d53133f15bac9b916ddd03b7b3d9201144b8212a28fcbddccba5bbe29dabc7a118767405223e312222c4efea4b7421f79171f19ba85d39ba8921ae6fe90686f73d3300311eb30ad9acb0ce1d71017ba074fd3c41fade616b0cbeff64b504a0c19912b08336ce387f5cd52e243c877941acd5751e1eb13269674ef24c61be7a75942319eff0031248d1b1042aff04c13512fa5f0b407ef00e443acaba14f806e7d15e4913fbd69307afca849658a7923512c1e22fe927e05d1f8b6553de3ec2020d16d1b3b93df0057c62a054d3e3830721dd9b308460a94e25346ccc39107923288f68c1dce346ff52696d557c090ce6428c60af425a7e5f723a7ab10bf96305ead9f5be98978c1ad3d98af344502c6b7f867bd8544c673a08f11594841422812ed50b8f6ec3e34eaf838f1de60d7ff535b98f9b06424fdd161d106a5b219cb2bf3fcfc80530a0ca5da4b6271f00423b915bd06c3055fac5669137c00ef6357179c5af2199d3676e824aafa2e909d007524c6825d905becae327464ee5fc35c9aff24cd04e4ac2d3198a29f2e5aa58a6fc3025336d636c84e3a4034f852d0fc395509309a6174978bbe68a5d636f40e8afc972e23b05e8ce4a928993684250e25e705db929f16b3325f9e0031dc80723d69728491616fd9ea767e7ba9705c1f4b3da8e3a1ecd904938beed2ec9b4e8921557c7757299ae4ef8d3e806c2720ca53176ebcabf55b9cd5caaf023b1fc594192405e3e8ec00c28cce1d10f450aeaf8c282a6fcc0baa92627db5d15d3907dd4a2c10a50674d7bc40be274da8304692eb163db03724f15b7ba0917e53e370306084b35068fd7718b2340ee9c80801a64c745e2078317d169579713e3f51464c747ce3c06407d8cccf1b6cf933afdd9e789d7209bcf08da0c10cf209b528fd79ee3dd4d1a7ef91e5132b21c56a7c03abbc2c0dfd793f957fc937ee7026874a185f3a480ccfb1578a408f0b58d5f0682cdf404d5f76a1196c40508a1d41a9eba8c88d8b5f720e315d99cea9653bc16d27e7f0e310d269321eccfaff86cb180671086ee58a739d780200e6855ffba4f26fd5c1311683c1032bf62d4ab004563b18d10c05384815a8e453e6a3aeaa4f4371956eb75dffa87e8b64534719708c96bf20504f02e24eed74b0e4025fc3191ecf4f7bd94f6eefb4650062450c0010e64c9c44ec8a2788eb6acae8859e62bdd396a03ed1d2365258bd5bbb751aee52d953c76799b4b29d98155faa09fdef96bfdffee06bf10150707ba55a9f93bccffed902faf1ba24fa53db3a4d14636b2ef8c6961d7ebc6d18927c0f0ab5b5418f8bd4120f591947539bd7889e0e3631e44ce966f1102420f34c8d9ad8cb57d42178661c78238fb05ca4b64637359126c36054ca8dc2b60308960ff96c63dc28577587b6cfb3fcaa1a5bd2b5091ea1aba10b47681743d32e0307bdbaefd159614d2df4085a396e0af4450d26fa2be49b69b9683aab7d490c77c05ef7626d8705e1dca29121d8bc803b1fe8486a2a0a6879b5a1565d6aa1d935c86fd470b15f435eb0a709bb9b5849aec8143746d6dfa1d6d1f577705595b3ba015e1c99dd563037facd797d70d3839484609025c059167304b8156f3b73c57293cacbd2b1a8b51a67a1e103a8ee8a9763e5fe1b62bbf62d250d748f059c64f82f7ccf52e2b05527175a2f6ef1cd5aec416294fb8f8e962d018c4a0751f7a978e24e5489cd3fdfce8069166e2ed71fc84d6cf7024926d6b815bf43587b266aba4fc467c6bfcbc330254cf137058657fa6c65fea469c73e9e1896665bc3b72611b5fb839d66b933a4e976964383dabc592d9e00c29b02619d8af971cad768fed747d3ddacc31a47bc4e066b7da251a7b77b5749c03b69e0ea81abe607de46cb7d08a25749c5aef25757a1071eaeb92e553a35b761d3019f3973c1e0be5408134abe8a7948358637fb493f185c5280696d43939c686457d744f780ee760c51bf90d27880a00ddb7b79543d404224aaf32e561d64d0c1b330be55804fc0340c8cbbc16f4ed7186b99a84112b352523487016c41466d871d478839091d7f4666ac1f48ac81a575ff378a59f066887f03a3e56c2956868b4f8f47977d0ef79444acf2b1c4976d816b9c0c8ccb07cb71d6248285346cac55a6d44d9eb9234eafed56cbab90505e56dcae26c8440fc5256f5a20ae23ea8fd109c8d1213f36f326bb708955a23f4f2aaeb043cb92f4c2486b70bdb5862671bab6d934daeb3ce1c076216d66581152af965af114e98752f54e4eab6894e26b369d938890ba0cd81255d719c4e01982d439ec1b3ac77c7e20923664ff2115fbfbdb087b24487b48c9a6ceeb3e02c85d0f7a1f8e3ed7dcad6676f04db64a906dac7da2cef57c5eadd897d0fd28a9bdd5383ff1c0b06eb0c7f04bd89c6c727515b23f1c9abb0d45d1d8ca8fa9dfc98f42e5e4610ff976ca2b251ffa0125c4cea045caba0693ba21eca8bba51d4f29634dcdd3eb59eb5afc14d5efd82b34b789fafe809016acdabe23f3d2d955c4f8fbf946919d55674d102f01a7928d275c6a4a5b78a720fd9a5b0313772e198b295739c32f9e35825b56f5950791252caa24ec30bd3d245fcbff07abd982455e90f505db42694b18fecd5b27d88985ec1f51457d3dc7de0b3b764e9b0c55f1cf8f68b1e8c9e69f289dd5b521497ce2a617a0d2c1f338b7120104aa675143c5627c1a0c07085dfe8344fdcc0b1d3a6a95ed96b8c5e499d7d7ede2c0c4290b663dcfaf9e8394901ba561680a45ba4455c672401a981668702a2a33a420222cbaedbc5c434af9ea41e7b48ee428eab14b3a8f1e938718bd231f714555642651bbf1b5b3d93172c06a4c24914469ff910f3c96eed4fb0676843808a17b38bf73124b1d7f3366efc69b3b5de1fe43d692b6b298da41c4f3a550bb422bc59c09aca0b8f49a7225c534fec8cc8cb10c16b5991d6d02595928597d022d920a17db79242affd30dabab345b02eab75f2e1bf5106fc701e8d8d3f447ec634ddda83b2859f0b9fa153aed165878a5c6bcc3fb7861ae933c855141259c15adb9463a31646d313204cf09a63cb7d0e29700479b42ff860c91121d39ca69e24d14ca56a657ec3115d9c49345b48e730c32b56dec1709732e5960ff856219f7a5c60c2ba841cc919ec78da608b2f5570c8ae3fbf7dd77deb65ce021e25070544ec4347343b9d323d89d8c2417e551dcc7cf1ceaca94c288b23eb84664a30f72b6515161fd83e7626df9bd70a3fe1b4738b368319c00ca7c22cc9928e18a4ff7833feae7e5cf995c99af39b7fc6f384024e63281c9d1a2ec80fce137661a825959dfd6ee1850774cb75aa67c99308dde7c9712f2fab3b78f17879acc795ae1332dfe474007192632c7fd53aa0ef48a6924c77dfb73a934cca7c6d12f9bdb9566d44dbe63b8bfe70f0e7527aee9d16622799fb9ab19eb4c2e77a3bd71abdf78a8a70e78799a5ae78f825946e2c557914ce0bb997fdc9ae79f56cfc74cd62a8292c08892a258a61dc233ac8a1bc06e35599915155f0f781c95b61450399446bb8a223cdff3b955c6278b0889e07ce71bef6c50121acfa7790d13b400122530f8c0739d759072944a918c3f5d04fbc43e9081bc99d210c0da2174189e6e1b2eaaf0168f8e034fa42264dff721a8173e2b5b602c4b1c036de91845f059b35c0fb35fde7ac623bd6be489f0a25eb321435bdd3abd2de57f4f58aabfec56bc3818cc2d41760e445187b7ccddb678e48578d41f2bbaf0181a4fd75ccee276e22f1b0a7fcdb5cff485f7ea6d6474d3bfa4f6fcb2c38167edd02d8fb80b2c512f402aeda64800c4c07e863682564596cccc0cc25169cfbae8e4eb3ff211ca5517e3341a28e935ab964e5598b7f43d13cf1a0a8037fe08a73c46786d8019ed4e2e4486503c1c70c2364cfbe3fb21b84de208217a2350e89df41549545c6b005c6405733d454b70db2910d8367756668c5d68f00e3d7f0445bbcaefd5a9930a639623eeb7f250f70f1d1091bccac0ebabf805606262837eb9f87ab10e989b9e9fd63a75d527350a8bccaa08d355201eaa3bd5a0357664460541fc3647f00df00b4c241c0cd2ad14bcf2f958ecd7ec0c672e9df75ddbe361a2a51e7e690f3c5755881fd1aaa8dfc4767b242c89e74232eb9ff5b5196ecac4d414f82ca1d28b221da65eef4837e2d181d1d3bcc69ec172618330f64d3b880a50abd8323511fab7a32920faca830fcdc831388e3d17c5f777e3c395054ae2035e3c392b603fbf312610c2e582dc37e7159eb9d0b7d31f121336cbf2b126c8a88185c40f21601e7a83cdb2ae390204b44f801c1d95e8030710ab5bbf50b6a067625792a3bd1e022574fbd7b2dbe0bf113fc68f3d04c6d5c347e1a3738477b0d160c7d190cf69e1345acdd8859343aac5457be524268eefa990b2ae142cf9e26382d9c878f2d93a4060937bace34fc6cb88e5ee7aa658d142ac1b4c9e04c73caf5cc79e3cc2d6eb859fea21709dac14be1c42c147a15a84c975639f9a80818e6c3cd800c5edf7c7fdcc39b5119b3ae76e9720a05eabe7e4537a3a62c2ff008117dd1648610770cae8508b3f2115387d5fe9285d0f483276513989e10d952e89851917f298597e6eb17f659042d82c19d4a12eb90a0f3dfcce9b967c5a42263999768395b1e4ba8bd99392dc6227b4f27f5e9eb69bab3c5dee2e1d4dff6907948d9cfcc17f859a114f3e5e170c5ab8287530120142f8262d18900f09c8a26117074665a4e12a1744d0957e9cd0c03ba65399d3c2dd66ed13c73b6f09fe6db9420272a2067df0e04c8363e1277337f472730fed6b65158d05ba6d88747e8e945ad67afab85795ef16ba7f4e48bc42de9b377a8500a525ee861d09a4507d130c768fa0c92524a9852f29a5158defdb647c273f2633aad1f0c0cd855abb0e12dd017716bed42ceb509bfb21217f758db76a7483a93f49624f423ed5f4219bbd773fc4bc96b3266f40821a6ef479bf8385f0e98b64b981662b721a9667360d96fcbbdfc13ab9f47bf23a9eddff2f3f7e6365d49c1327d64171a823010a5521f2e48dd2c8913f331522e848a067a7912e52776eba4bc4f16288e95369a92aa344b76c9990b8b892688cd14d47d0616370f5e54727ae537bd907ace70c9c5d7060c458ef443acb48b5f82561554e65fa564bc1dc619cad1b6d22f6792db197ff5393762e8757f1481649951c611a1d4d4f21dc6a6457368008dab681bfdbcb75bc6764d5877f7f36f1ae2da2ff97b8581b4b7a6e280eca6be37dc4aca252c0e37082a439323fcccc73d91cd68126e375cb88fe16059d42363128da5e112575a349ef0cb2626f6bb73d42b62f4e4f4ceef0fc41faf0a40542509c2434c364b028a9bb46da600a8f128a2179d422c1c3ff94f53ae6a66b7cfd75ec3d05ab1d670bd20b2070902af2e783475807a9b03780ed972f99dcd9d1db2ace8555046d5bc0afd4e98194ee0c6fecd567fb49dadcd3675af40f658cffc0e7e0a0806281fab936a08c9ad02ed73fd96c22446078b2e010153e5a311851d91a13bc7b2362866de809892299d7de3fe9f2f8bf2d0b8a337af8d33263e6114406d5185e822326d51ef24a73e92fc9fe0b701f0604c60c2675ebb0faa5801380528ffce08eadd868b215b3900663c3347249620dd900ac7dfab20400f1c12c623e386d0f344a4aa699ef51a7cf458dd59cb17027b916e58fcfa5b308617c1dae2fac729a696a0003ad915f2ca38ddc122f19f4e8f228e63562d132bc18016878bd47a1f8e3deb503210919d5afb6774cc844c44940f76feed7c868ad3c014777e69a016f14b52551105ccd2bda3f5c2cb67aff3427aced71d6e2e5b7a811bdfc753edcb86fa5df414f2c719a0df7ac55f203da67fe59964d851cf63fa83c5d66d53aa1c2e91c71179399c0ad6c41f8fccdf7768fc8342b53cbb703e432bfc9caf158459054076b3cf5454976a6264c6f26e6481eb369202b97e57fd78d237fa9151058bd9f36db8d796fc05599c883cb8a4765e5748ef82684310e5f573fe5601160d4f9575e82505da55","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"12345678901234567890123456789012"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
