<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9335ad69a8004833028f3c8cba37b9c9b7e2fb9d798a094d38451918f9449811c48973f06ec2f79c8f62760266d1172746ad42b3191ff8f11ceca272e0563b3be5029d45ba09d283a3ee1b38b9b0a52613bac6582a46118683f2e775b0e480d7f13ff24a34176e4340c17e06896728db6208af44a8af920a4686889a3b7d8677572b99725ba56d3ed42a2359e54d3db4f7606a6c40a59d55b3edbf3cd88aa972526b6ceaeb6dbc130762a3ec3892a44185d0687fcff4666c0a40ecb69b8acb39e37614dd56b3742742f41e8bbfb85579f84d9ed6b79f886d0ffdb809bc78153dc1b4b51040a86909d1b71f2446634e4fd48c2902f04e44f2d7bb01816370ee07e7e8bb7d53d6f71569dcd0dba51cabfa188fa92d30c0185329264de53e53b8b7daf3f3cf4e95db7c5bfba7ed011367e0b027a4ceb0dd7b6c876c52d008a8775f1d08ce8dafb783e86da52a318109e2c90d170e036ce4482ab06c9d2f76fa6ccf996dc054b8857ab1861fff0a089117c0855c0482068727e50022582c1125f8e67e91f89ee93597555f0f1ada551e6af079e4c4eec51fb49d2e2ed57a98ba998b953161149d24417a97171a8f004600ab944d29cb204e5e178b3445ec5aff386f0305eadba3c219e8f78f9f52897df7c962c3db9b1743facace9e17b8d1de689ae63de06ecd2a4c42bb578b6dc4b2032742d15e00c7f3739458fa8d66b44497efe51c77de45d5c819a7c6157d9e0e13f0ad2941727bdafb5308538de9d6c5f87c5b79f9a3b294349a873e04b49dde9bed7e0efcfa95bd0e717e574e34db418840c0c392a1043d02dd200fea0576ca1f374a8d0415d0a56c664bd1d381e426c2f80af866b610b5d95b0a3a4dd9b0c84ae1166688d238876ddc225bc06b6c8ceca455a1c1ff30b3abe5f5ade76116c053e345fdb82dee89da11edf113ba4e50f3353fb21ba97685bb56d6ed32efc95a9efd5001a9801d85b5e374b844e7a38479ccd4d362eb59a8497fba8d6cc35afc499d914cf199cc5939cd00e09ce116776883cf5321d8de745cbfbbbee9cde6cac0a41c5badc1e6bb81005e44128ffa60d5e1e7375c16631120249ed6b409e4d52d55c763eb4787d2060613b0e105244f034f42a2308604aa723b6a4e117e90af306ac1791cd5e8813ef47efaca8c23484a5f26cb5fb501ed46e7104f93dd7d3e6b7b98c0cc75ce61a572b566df55275542ebb874860ccdb44e47476d88ca8b3588d13ae4e5002a7b3230cdfcd333ab9872b8692a2458b34206168cf120b9df140f283320f6e29540d471f768507b5fbf719707e1c9bc0d6d2aa5e6e93db9ea4def28014aa00933c62161dbf78947e66fb0d2610d81f37b654161810c29ba57c9fa1a6e203911860720a3f870707d1b53e78cb762479e59818081e2a253df5f7b65459f7d4753b5629cfa5b588b986edaab28d4bc744ea07df886cf58be2a44c063a545a5cedfd53f043d1506a5abe6cf956fc4586524356a46489248358e7829e701d1f01c68dcd58bbf84f9c9bb37e8e62ba251fff6afbbaed63d7e8af707eb6b3ff0498d887ea926450460ff94d190b70d89d547bb790988b1f965a5adc52d8454e32608d08ec080263301a88c9b334b72d094358d6b63f15220334d58ea0824c8d7324209807b1a48fb1d1a0e719f6b15922d9ff82230691a5b317aab9d52f3bc0c5543d2d463fc489d890d2f33c4df498f83c6b27a3916391f5d12c2925f84c51a381f793aa1b017257943c3b5f893cca0b8c5f1ab1e51ef3d3cb12e4e00a068594b9b2913e5d2141727ea5b7418ec6ddbee38a7096eed48ad232612cf4199c28ecdd602e3e4f599c42baa5b2a376e7e00fdf6d62598c7ca534b3ae8e49c8e0124f43f1d8f77622057d06cd8e8959623f3c912c6431211b6d78d8b51fa66905188845367dd4fdce52a97c85af1544697e1fc5fdf860c0b7d38782ab2ebfdad801a691b23f03c4663ffb97ea346a253e6f9eae5f407afafd830662299f221b05caeff9b13e078c934c88c3ce9a4a3947d70c35b5e372a78c541df4b6565034319d7239acae09edc77d1cb44906ffabc571cc4d92ede7dad22620df5a7a59022e78d0acdec644dabeb18d9fe9851b57d9086e6308c328837e9b007f9f3e2d3547785e86e791c2538f3146d08e66808c086bd493efb4f8f179ecef4ca49a0ca0d7aa42a2990cfbeaa121a4352ea6e902d93d1c51870a89aac832a950e42ea848908c7a6423e04469fb3551544c2cdb78864ce4bc825c8c7d2bce8e0ee22040a06f94f19da87acaaf98d7bd6dff81bae4247a50fc03b56dc6470a8db6fe97043383ff995ab219df1cdc0c7401c09528de5ca9fc54e04792381bb34f75dc5d2727fc51604a889d1177c56f5dd23647abd2a08a23bbf573edafa7ea9b8259b3344ca44be62a5ad920f77d6a475915a2a6a7b6f51c393bce188b04ead58822c81af6596d0ece4740d9f6d0538791a545f9c9225c2ab20e937db8bef609fd0a03c5b9c0725f453c97b47ac7695d07799db0ca21643427f69c3c99ff638867df5cf92dcf5492cf6c3400fed709ade08196a4a3e5d78e828daef0d7925bef40bd81188f79a88650af9197cf5d131dba17967ddccc5a81862b283d978c1e37e72553c7cb6b55eaa848968b05eb98144280ea4d9dd886ac045027b022e07b06fa6b312ae74d2c1a709e6a7dcd78e0e209772a14147be06137a546b2f922f2a34b4e4c354f7f05689c42e710a5fd6329c324f5d07c2c631765684510913b9076315c07f44402e1ee2d7360b08b6933d57b48afc4ddd30fe59cd9702acdba8fba658653fbe362fd777b17fa36cf12cedabd0d540da940266bc80825ac439e97b8257ccbda68653ef56b0143ed4793f9e1d89778b78ecaae9f70ee364e1de1dbba8fc4fac7c98cb9eb91e4f1896cd65f36d47bcdbf61b16b78c431649d2743438b9d1308d22b612207e4a4448a9d989937243d1024f233367819445d45dc093a32b515a87717c737905b03ac0874936434f15e2369c6184dc629bf01a278c0eb0e00397e9722569cb8b00e6731573746ccc6ddb83ad69f200232e8a740aeb20aadc0548d5d45ac74bd49fbd5fcde656d3557ccdeeefbd17d71b0d00fac4f4804a4f75a055ec95dcd83658b514bae7ac1d4f663966376fdd5532af7d2be78643895c0cb6ac02fa3435d110d6c8f95ea7c73677a2b8c0a89eeccba77873cf819d0cee403368c48303c79431afbe98e3a472ed3a349eed1498f877b5fe73c44fb4cecf22d5bf309398670b1a63272883682c14e1ec7b3d1677133110ea80b91cbf89d28aa10bd6bc67ddd9bb8f530a4752a53b996ebc46385b23b6fd0aa31f221e23b0ab2dad54b6b1414605e42054ec5fd26d8385e820e0f83f5fcb77913acbaefd6cf207960c5632b79239dfa6f2706037642b5eb0e1ad20c56b079e1ae2a51b51e42ff8fdea737d944d15cd6c75394ae2f59f76c917753cb128557f5ba8fe173ad1ae3c7b01c49c867d776af56156690f2ffc4d9b5ad33f54f9b0127d0e5f274d7cbdd45cabb269b02d1f83a59a1d6ed9654d4d84ae8e7ca33d338a2f7ad76c50ee215ea7fdfbfc719ccf438e8d0bdc56282494ef5065ee0201d1d65b5bd847f9be2d25217d61e63a33d7753aa3c9f386f2f40f934f45a95e903b1f032b9082067dc9882d6e0f805ff4d761c8dddeef22c56d193ca978de4ff8740c99075eeeb0660cf038faf98cbb6ce2bd9222ad2bcfe0eaa78081fddaf680af970e856cb53e06a6b2986532c0aaaaac91a0954c473f3097e24bd7aabd32ae3b96c22ebfbeafc7a925d147e68efcb1c7d77082c069941b611a04c5f2b542b0776c59b969e646e68a30d529076dae1646ed4ef1f3292fe1b006db584ca444aed712828187dddeb3d12f6384412081f6d0ca3ce0e24a48793208b70002d4bffc80bcab5c9d12aa0b40e5c46e7e28a1e9e174989f6f3f414f177d015cc29e5279f1ccd457dd1eef445eb1d4d88e94c3ab7e737575b53da994333323d2fcef7350885cc9188dd02d080b67b8dd76a58239c37430130ae31b0c73d49b0f92c4189a2f4ea343831f6e1a3fe2a02d52cfce8a2eda64d94e395172140123a050cff1612f0e820f5433c3489330187cdc5d15e542346790dcf30b4f1f4868f5eafe73f780d29fa42697ab14628fe3c4563dde827ec2ff47a65aa502819b166b86c711da48310a4f023809c4f83c73c79ad2509462335a9259f8106a1efd2e9ed86a439561c5a348e00f8b290c80c07eed5d715538e7ad1117146c48a7db94d06517aaad2f8a3ae3eacd372b1c127a8acc8daabd747a809ca77aec1271e6b7cc77deab0700ecc5b8bf0fc4bacf4b797b7fa5237e1e8b09e1d8a85897dcf9e9d21c6af34e6ba27229b062ef1ef2758a8f19de64046a61027f83e7d0ae0b12dd813c1d462aa066f7371fc8e86a37ba72a879299e3cad78714f43906e85ed4714407f513da664e4553e2bcbe146c5a26802353bf9401ad64c8560592a0dc2fc00a505133ea87117c1c451a92afb32d2e188d7ef604c415ab630959bc9c53b672484a09798c0c91b12f45f67e60e6e5a916ed46039cca190d7ac0b9342d74545208287e59359c169f6435802f12e016e4146042661f8355b93cf7f59ea107fc33e7918dab18fc5851fccd76a709a8055162ab8f8b4b7648f032a5e74642ddb615c5742f6caf0465017862a084b32830a4fddd474c29eb71fb239b4ff467fa1c0222c2f9474d99e8bed88a97a7515cdeb48041c49d068fdf21673b7e4d86f3aa901c3e01c510a62b458bafbd27c34eda36a9a24ed8a97c2099a5df4f322cf52a92efffb3bfef368a8c925f9674d9800b6603b7d28d4c88f569142e7e60dd0aef3e9a0223ad1042477af951cd2bcf7bffcd776fef987e493c83400667262bdf19bfd595354997f84ac857b90c88140f43aa5913b97d9fd3ee1cae2ea5a53a821b63ad054d304aacc4a204e847578d10fdef7b2dac2a894e4b5e26c28a7f7d4dd5cdb5ec69f42e0f70bf300674d68e221bbd3aed6ed9d98b3abca5f6633455e63f94ead3076337cec8fd41dd4e72e7e1343c12335ce95033ac87ca6ff4facc93c3290f869cb16f8ad1c7ed317413e0eab3bd985c40b323c093d581e1ea47d0ded0ca59ea392aa8b35415b113fb462d4a4564372df65887214d84dbb951af8d8bdc25a37a1c19f36d0dfd02b7b2e765c413d0fe77c43f53c86040dc82eff575aa233d9c232f127f894334b8f9c3e9277500c4d5563abd072408de141841b8398f1afbf314bc2ca44a1cb71a8e1a5538ba75e956a89c09b723fdb66732c619bfaddb554f68a227447e0952f846953619db6b0edfa9dd9550b735013b7a33b8ee0c9a8e9beaa3bc4a725efcdeb95849cf4a63f0d895a8a04525227d64754cdf10b61e881f4272125c12bd5f33c87e29a3d7b302adc71776524f42a10df2dd27ccd4fd3babf3e0ba6f549892645afd0fad948be3794600fdaa1940fbcb66df6e9b0b0fe86081717cd300c752e10ca4bd924d1f6797b230118e4b9e0678d08dba1762eee78614faa571e491b2de99e6e65b75621a8665a14c9150fbc8b2d72a76939e5e1867e4a0528cce1caf3df0a369e1303ba751344d94429593eef3b4026ab8f00fd22938cf81099b5d7395a4ad7c1570aed169c0c3236c75f7e2f58aec96bc25ba2c71b0b81a71fd03dd0264cb1e58d65b5317f12c92096adf92c5d4ee0bf704cb42e6bccdf9c93769c6db4d3acdeb955b32e018330ad002fd4b86468fa37b384e115e840abd13dc78fda1b1fb942a8eeb9484ff401c733c6b99b2a98262c23a230efc114ac5909210e0dba92706a617e50d075406f4e7cc58b0522be13dcc1f4fcb24bf04409660674dad6c795e5b612e3c0327243b2356225a23ec4801e9200c8257772afc3934fd70ca3d9b1abd4566d6a514ca5929d357c107ef035ba1309219782ca1d62af6286aae6f81ac8a4c86c0c649b020acb19fb4f6fe192422391645e574e7b125b4e1a835444701e0669b7a2e1da9894bffa62ae0fbdba5597d105c177a1c01a595a965f66cb2faf676440eeccc3cadb5b6696139015e5f210d7f1904e6846bc7fb5133f5e713be01ce87b6490574f1dba190ad51fb163a68d947bd33d886821db5b86b47fcc8c5a2d16b5ecb071df2ac560e9b79258456e83f2670e1b3257b9016acd9ec231e6787e4800fb637ef750ca4ff55ffce5a42573ec92467dddc31b5bee9b8434c5f607ef73a68fcabaf61c2442142153b5d0eeb0fb8427a8bf07adcb4585e38beb5f016e8403a01399cdba92f415d2a230ee5b3f76b04cfdd24bca27b495378560e8c8a9c48f3cd7cb29e77b16c5de8cee6458035346370ca18c3a1ac9cd5ee4037ef3d4b328d92e6106435a623a0a257dd4fe841042531f35614f91c5a4f174a3da8fbfe58af17210256ba002c58d68019ce20885b54d6813aa38b6bb40bdca616d0f146e0facfc1ae7e48b8e37c619c144a27b61ed8f952dca2b7fb2882bc1e0da9d6f9200a840af03418eccf9c12c56e9ae037b0b93100928aef04edb80bb2b02251b8c2a20bc8c84b7e620b76db1e498f5ef733b56a0662047750e3a63961d5e1823632cda5f94ec29730b9bb36fabc0e3d960a85f8ebd8330461910b8acdda7e9bfbecb34b561adebb0aee26d35589a44ed7337a377b659c070b5491d317f5359badc163130aa115a9e17d368a0b2dfa683cdf5cec5433d486fc05d0ebed6e829cc79dc4d410980ef8a9484cfd631bb32dbc8df40cb4c1f9be159b114d8cf874848e7322758b1a761a4219a9f1912670880a7d5248d4baed7c5a9a617d4e2d42d7d49246b6985d291068fe81640269d7c126c990df46fdcda1a14eb2849252fda820a27d1ccef6049d73da6782601d5d30954bcd91e1aaa57d3704e04b03151f594d913d7eebb6ad4d70a17091b2b18d12376e2cc5d46507f566332535d18952b4eca34a41b4ad384f04988693fed51e1393e264c67ccf12f123d5dd1abc285a6ca0ff0a412fa375866b1f8d9b90081f8cbcb4b37fce6e500ff0ecff0ebb0de5fe136d98004a74320c9d65ae12b1672d8dc2ce660ec9020fef20b4b73aea19951dc57050df731b4dba8c36b72c72a2715232706c9d8e60285e9a3615a0473b4fcf799a7fc9db37958fb882f8b67d2533e1065de2588c9a196a3a5cc66fc60ebd7e4aff949d5034a06d0c77f8c0782e706c9d981f7429e484e03c4b203e2d831fd3a5022cbdd09cd737d0636ba8cc3fb49a95c1581e871c08f97b7cb5ac4ce93d720a4bf1abffcadd5d24ed890e100ce08d9a5466c5e752fb7266396dcfdd84e30c24e3781e912c03d5b8ba18bd8f3d442dcedd7ac9e3d43994bfd82e15eae60bb3240fd7cbc9ab6a31d9dd316adb8030a73b433822e0d2b6a9f4539b6c42e6cc4f39a8b40d7dd52dfba52feb439ce7a9d777558e9575d0ffa5d9644c033facdadd09643d8e9130a00d8523dcf1344d552c58311c2c5b35642afbc2eb82235b8571edbc62a46865092685ccb5f914fc948bd0dc303767e67298db63e049c70cca5535d190717c6acc4b6dd159f50b04c333d2fa9983bfc85c4517b8bf7986aa820b6d83c243a4e5274697acc04cb89a0d6c0f710de66a8115cbc1e2c210f7935b6ed8bcf39396700e0f4f98c932ce622b846d39d8d21803ebf8b9db4a357f84e03492c1cb07584033c8cb7b896c781bc417ce6885e7dc6ef432e2fb4d69dd6db5379204486b4adc67ae26b5277bfc2a71d07b153aef6a6cb98751a9181cb7e6081f161747bd339078da375ce5068a513d36e28af2222de0e225e47b5a97fe39b1740b733ae3c59b196fbc6e1a38e787701be91df0e5c634957391d71bb160908bc2812f8dda8e68adb0bbff977d015b00e632740115edcc50495f6d81faf2ecb5597a2aece978fc50c08f71571ff6befd01b2531279c34bd853a14e9a4309c079a31136eb633a03410070460c80574486f9a41afdb8bd83cfe0935c68da5fe1cc6863b7bcfce762982687a62aceea512c348bc013b78c173d40234fce2ca8620e11cfba09c5482e27b5ab29e2fd763c1478c4e30755dd3df22aeaf27365dc1a376346039137e080c083fd792d3b08fac9ad936af8012450d3a084dc36498f068b8023e583629b91e9fba1cd4de7056d17705caa6aae51afdfe70043cc817ea9a7d895ac775b3d63a8ed0755d5a33d0f32527c034c5ad48c22adce70bb6135e2342a4f0544d3a3a548601e200c96ff7019c5192e1e4017863b2e448d5d7f12b6123b24a7c9b59d65cdbeb1bef490bb2a834bf74eb0ef2df31a68af6d6c6b081a611d76f20af24a8beb45a6440188391b1db3d196acb781bf1a71984d9dfcce8e680ab225da2ef62313f4598cb1d14b5a00cbb2515b6099ceb0db8615adfdf3cca47d1070da30fd66267b1b6d28d1c6e1f5217e4862ebf6fc54a7ab7ac60de659e6d3114fc3686272fec789bf709bff3e9b5b4cb05ed5a0f3537e0b699a553b1199eeb9134201b0b1b245aead67b7b7a81cb24b5f5af7c11c2537118761047aee8509c1ad13176f32c3315322db81a5333e5db354dfc4f5ffcef51da7e6dabbde25cc673ced9b4a654f77231b8292af51693bf8d695fdd706a4acb4454a15c8b43b8f05c29b78b6bfa8200bbc32626e03d1e2f4e9082e44940cb9a9514c07be16899f4e84216054eb573018e69d7c8331b1bb7df3794b7e82306fd3151d33a69dd0885a339acd53e83e3bd18985a0fa9a4a14bd455633b886dd457698ceb0c9da74fe3317833c6214b887d2cdbe1d9931c396fde82f42723092fa22882028f7a7a6043657d512e82e6f028998239992a4577d405c76791a6b6047fa9498aab8a4e91125150f3bb56793e5c755fc131e7b44130e544fa1d96dc04134a6f69f4f19a502d37942eb9569f032f2dda6b88ee7b4edd246c7946f3857ea8fee6ad4602177cf84a20662fd7f99900e82c234433b41291da25e86f455683f281dbc420f41c2b5fb8938d04f7789a03dd1f559ff13692c8419d54ad2bcb200489bf5495455058d884b04a17571501f1ce4423cd996aadd533d5c8254389185291170a878fe12b280a9a3f02ee06ffc700082f00c9264d23161b178460e765084e524bab76b3323f0260b522e4ce0fd708234d03530d9ba1a471f2c7f3be98510f131e87dbd8eb5e83e49a730eb82abd4696e75ab4c23e5001a85f138185b191f0cdbb5f3147bdcf203d9acdc5147613619cc2e3234d8b70971eb782c54022329b76a68143633c5584712cb1037cfc7a3b0e54c83b59f7f3cf628b9eafb23f2e8449b863c70ff09f9c4379ec0172eaab25bb0469c188b9aa3ecd1c419991ad08bc84b78945abdd7f789ccbf5fefa48b7259dc830c1b02aa387eda323f8bd7f86b41124c925686062de51a99d3671e7c56bbd24173861e5d46dd295bbb3e74c32520406fd9352e62685ad3314aeb4fae77c4561d0409d553765472fc84889eebac4d7eb1d5fc4bc6ddb36d0884df666656fadf228d578df1a9c9db4f956af4de512ad5b15245ca619f23944a00779aef31fd528655262dd14e56179032f8ecc1d140f55ea05070c4fc8b05e569a13304e89fb3c97687f0d5f14acffc58482fb23b3a8a6b278deaf42d7ec74fc851ba4c55e7d6d239c17a0d77dc809925a1246ce7f346ffc299cda304c026aa8c061a9a2c551a4548e616f7fbeb920db9015eeafe88ee1304d6aee00d910ebe55182eb86b8d2f9f47947de343cc1317917615fbd8bda3b0c0b6aef355676033185445e48d8277ca19c713458014d5c95515e4ab9ada420328ad9101dd6040c6339875ee99eaaf1b27899958f3cfe1e924f99300fc42d7320fc6766be3262b19369c3eb64fc0b1e4744a24b004b837360115766fc0f9a56293eba057b707c57cf603cc316766c59ee409d9beb647b8ffc043a52807103dd0506a64f2fbc36456dd7d7854e4deab5772f5a7a105411c8a03f2ba483ad07d9cb3fcfa349d0b49aa6cc10426751de271562b569dc77a14b9a32695761c3e1687d204f2136b79cd50eb7529dad9c6ae8ea46fa79c97f6d18b3b8cdaa4e41046f21f2be6566cb26cf015992214b9e1d54829ff12e8e3372093b857a12be9b1e2eb2d1da87b1bbba10dba3e07df669b683cb636c2a9f9e1c50dfee9a9c981d1c43ed7e7659e68281b892705d32fb41dc7582cd7576628b8f5e83eb916377e5e6bf670a4687fbd849d1c1be38b63900fd9dc50830cc3f55c395b4d31b188849f151db3e7e66c559f2ce1b34155a761a73641353544a231f6c694b5860ff4cea1b5dd92cfd8daae0b6abaa380bca8c64cdbd9bc6cdd6ed6d89deb6322bbdd10822557b4dda3ff23a2484d302ab21ace7e4eb80a947e417047c7d73a611b8d55f4e1656cd99bdc7e4c4f4c03779543ad9126091a793aaca842f82cec65b9088ffa1501c0b329c4a76eb7e62326aac3a408046242b4f29b978fbd153dfaf6bcea0e5abd333875155ea45c7e09708c453bbca02f93cb2c54e69e4e4790aba3621fe0247eda37bcc68519389aa9031edfa62f35feed4d90aa4dbdb1a7afbce353a9244c29b066e0548cdea66869845becedc18b317b42a2e34663cff7072ebc060e434058bdf853b8926b24c533294846b97445c953030ae0fd9756cbd4469e8b7067987f3ea7a5696e369f10b4dfc40797fa297d91d17ef48457395e3ace2c7c65e84b06e6ea9b0b3ebdb4a57b57a9bf12be647892c789d3dd9e5b7694e7ff50b3e69d39feb0ff00d38911a15f6cfc691cad7efec0413211c8cfa7f0818c64db730051eca379fb3f2cc2af9b1c8d5b989397fe46f392b03173c9015172855c2e702f53810ef97cfaaedfc4f831f2662200b7ef11830b17b3807b37421af862a41e6235a1da4c6a0f891c7ed09144705672cfcb41b590372c82eb6260281244e0f76bea861b935df340db8d7f827659c2569890819a8ae572bcca3517f727903fb8d9183d6629cb2818013bcdf5b90a54b2a3802de07a935ad0bd9ed9c062c074114fe7bc083250d82c71fa0183cc689e2cfc277c248524f7eca3dee8c0d694ab9571eec6d165a96dde0fe6f22b177fd5720c799bef8d3d5588cf39064baa8c7e9af221e884a20702bd11a85ce818a5b23cfb4e26028fa822a009378b3d03320c0d4f8584dda89250e98fbe092313b97e5663244db1214c869f27c2ec21463fbbbd05f45b108db03ebda2c5f80322fea4fd60704e15ff03b584fe25a6685e3f22631bc812152677f78a97854ec2f1b80ba8df6344ce6cbb911c7ba60f64924267d1042b7b65e35e5c673afa7cfa1360c9a3b5aa6b7c48a9432038c46d9f45d568f051ba123bd3f944e8249b08b9f73a83fc1f4a3cb1d00591a323564dc78e0721165306c7914d60879cd2c070e2f58b19d6f9d5f6611132896b122795eb5a4637d4c62ed18299fcd12757886453352a7fbf96baa66d3fc9d281e966d9cf68320d4204d3ddb665af55a07ce769a145d54d3d1f94965ccf7a6615ebba333242231e4e473fcde5987592de3dab33e86d3aa8a4217669eeb5815313a2830b299e8c8076e94d79bbced4ea8c5b409917e63af83e17a2406756cf87a44578f8d16c7622416fc3b714dc4eccaba50f14e61994bca4f8c961bc1196b9bfddc4baf6eac42995f787cc93147b3643d3a716aa8f3f7c1a937f6dd381f5378645a583fbe63e38bb197387c46d05929f2e8b5fa2867b903319d91e0f05fcddf0bbf5e646097061e58b657184f54336e4483a2c0d44d53a45d5964d3bbc7f1ecb8a0232bbb93ae1ec2eee5ef13042eb044e6146ea94365821ce16046c32152a2242d8e47055a0a1e7705a3c14298fdcf5e881d611b522177ad7173245be0bd03d51bf64b6916292790a70bb8673e756498f1b0604c15676ab52df05bf4675883ce44f608a71e930802a7a1becc49952355143abe31179c22fed483fb0e0a9b0fafaf75cedb3a928d02ef790935107bb0d9eaa50cd2f1eefc7af1a7843c667505ccf01294b7e7b4a907f6236735862d299d59ce89f50b1e766c358d39344949c08c8d9aeae3016eb4622ba9ade406d224405eb30a271a9989db3f5f8e4389d8e0f8b56133574f9c3ca4281fb6df5150a006d8c45a470cdfe000cce7436d1bfe3995d93286bd3eb31ae1fec8121f81b1e81a8edc4f24ed0a5bd5df3c6aef513ea127f943d94228aadc03723525ab683027b3a25ac265edf25ee81dca5cdeec3b522b3d8b3f111b330cc89aa9c4f576adad362cfd734ea877416060cb81d037172c1598d77b930504785f7f66a8604636c13423cfffeacdee4a9cd787cac11e90938bd49ec9bfc42585bc434d54c86a214cc0d305493304d32807fa40def347064342300bb800d8a8be0498a5df9293f228ac2619d005237a8c3ced03c72088960057d18566e1db2f8c990ae34b5ad5c662fc4609ee919692aafb77c0b6f7058174a6bb8b6dfb2e86e6e508d0bb0d1dfe5d62f231f544b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"12345678901234567890123456789012"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
