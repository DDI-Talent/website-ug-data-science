{
  "hash": "ebebe5ee4c9d31f68401c5562996095a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Topic 1: Wrangling factors and joins\"\nformat: html\n---\n\n## **Working with Factors**\n\nFactors were mentioned very briefly in Week 2 of this course.\n\nLet's just recap. Here is how we described them:\n\n**Factors** can be thought of as slightly fussy characters. They're fussy because they have something called levels. Levels are all the unique values this variable could take e.g. if we have a column with data on sex, there might be two levels, \"Male\" and \"Female\" or there might be three levels if there was an option to specify \"Other\" too. Using factors rather than just characters can be useful because:\n\n-   The values that factor levels can take is fixed. For example, if the predefined levels of your column called sex are \"Male\" and \"Female\" and you try to add a new patient where sex is just called \"F\" you will get a warning from R. If the column sex was stored as a character data type rather than a factor, R would have no problem with this and you would end up with \"Male\", \"Female\", and \"F\" in your column.\n\n-   Levels have an order. By default R sorts things alphabetically, but if you want to use a non-alphabetical order, e.g. if we had a body_weight variable where we want the levels to be ordered - \"underweight\"-\"normal weight\"-\"overweight\" - we need make body_weight into a factor. Making a character column into a factor enables us to define and change the order of the levels.\n\nThese can be huge benefits, especially as a lot of medical data analyses include the comparison of different risks to a reference level. There is a handy [cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/factors.pdf) around the forcats package in R, which provides tools for working with factor (or *cat*egorical data).\n\n## **Factors Practice**\n\nRemember to begin by creating a new project in RStudio.\n\nThen download the R Markdown document and associated CSV files by right clicking on the links below and choosing, Save Link As. Then navigate to your newly created project folder, and save.\n\n[factors.Rmd](https://www.learn.ed.ac.uk/bbcswebdav/pid-10560779-dt-content-rid-34734601_1/xid-34734601_1)\n\n[melanoma_data.csv](https://www.learn.ed.ac.uk/bbcswebdav/pid-10560779-dt-content-rid-34734602_1/xid-34734602_1)\n\n*Note: There is some [optional]{.underline}, advanced Bonus Content at the end of this practice document.*\n\nHave fun!\n\nOften the data you want to work with is spread between multiple tables or spreadsheets. Before you can begin analysing it, you need to know how to combine these datasets. There are a number of different ways you can join your data together, although you'll probably find yourself using just a couple of these joins on a regular basis.\n\nThe ones we'll cover here are:\n\n-   `left_join()`\n\n-   `inner_join()`\n\n-   `full_join()`\n\nWhen joining two sets of data, R will look for a common column or columns on which to join. If it finds a name and data type match then it will join on this/these unless told otherwise.\n\nFor demonstration purposes, the code below creates two tibbles (tidyverse data frames), *x* and *y* with a column in common, id , which we can imagine is patient id. Let's also imagine that the two tibbles created here contain different information about a group of patients: *x* might be about outpatient appointments and *y* about treatments. You will see that we have intentionally included some patients in both tibbles but there are some only in tibble *x* and some only in tibble *y*. We now want to combine these tibbles for analysis.\n\n![](images/week4.1.xy.png){fig-align=\"center\" width=\"312\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'tidyverse' was built under R version 4.4.2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'ggplot2' was built under R version 4.4.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\n# create a new tibble called x\nx <- tibble(id = c(1, 2, 3, 4, 5),\n            x = c(\"x1\", \"x2\", \"x3\", \"x4\", \"x5\"))\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n     id x    \n  <dbl> <chr>\n1     1 x1   \n2     2 x2   \n3     3 x3   \n4     4 x4   \n5     5 x5   \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a new tibble called y\ny <- tibble(id = c(3, 4, 5, 6, 7),\n            y = c(\"y3\", \"y4\", \"y5\", \"y6\", \"y7\"))\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n     id y    \n  <dbl> <chr>\n1     3 y3   \n2     4 y4   \n3     5 y5   \n4     6 y6   \n5     7 y7   \n```\n\n\n:::\n:::\n\n\nWhich join you choose depends on which **rows** you want to keep and from which datasets. In the joins we'll be discussing below, all **columns** from both datasets are kept.\n\n### **I want to keep all data from both *x* and *y***\n\n![](images/full-join.gif){fig-align=\"center\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfull_join(x, y, by = \"id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 3\n     id x     y    \n  <dbl> <chr> <chr>\n1     1 x1    <NA> \n2     2 x2    <NA> \n3     3 x3    y3   \n4     4 x4    y4   \n5     5 x5    y5   \n6     6 <NA>  y6   \n7     7 <NA>  y7   \n```\n\n\n:::\n:::\n\n\n![](images/week4.1.fulljoin.PNG.png){fig-align=\"center\"}\n\n### **I want to keep all data from *x* and only matching data from *y***\n\n![](images/left-join.gif){fig-align=\"center\"}\n\nChoose `left_join()` which keeps all data from the (primary) dataset *x* and only adds data from (another) dataset *y* if a match is found with the dataset *x*. Where no matching value is found for *x* NA is returned in the *y* column(s).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(x, y, by = \"id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n     id x     y    \n  <dbl> <chr> <chr>\n1     1 x1    <NA> \n2     2 x2    <NA> \n3     3 x3    y3   \n4     4 x4    y4   \n5     5 x5    y5   \n```\n\n\n:::\n:::\n\n\n![](images/week4.1.left_join.PNG.png){fig-align=\"center\"}\n\nIf there is more than one match between *x* and *y* (perhaps *x* is a list of patients and *y* is a list of medications each patients is on), all combinations of the matches are returned.\n\n### **I only want to keep data that is matched on both *x* and *y***\n\n![](images/inner-join.gif){fig-align=\"center\"}\n\nChoose `inner_join()` which keeps only rows of data where a match is found between *x* and *y*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninner_join(x, y, by = \"id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n     id x     y    \n  <dbl> <chr> <chr>\n1     3 x3    y3   \n2     4 x4    y4   \n3     5 x5    y5   \n```\n\n\n:::\n:::\n\n\n![](images/week4.1.innerjoin.PNG.png){fig-align=\"center\"}\n\nYou can also think of joins using Venn diagrams:\n\n![](images/week4.1.Venn_diagrams.png){fig-align=\"center\" width=\"497\"}\n\nTo find out more information on the full set of joins you can use, take a look in the Help tab under \"join\" (or type ?join into the console). The [data wrangling with dplyr and tidyr cheatsheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf) can also be quite helpful.\n\n## **Saving Wrangled Data, Objects, or Tables**\n\nOnce you have wrangled your data and/or produced a table or object, you may wish to save and share it with stakeholders or collaborators.\n\nTo save a csv file, which can then be opened in Excel or other such software, you can use the write_csv() function, which was discussed in one of the Week 6 Topic 3 practice documents. This function works as follows:\n\n```{{r}}\nwrite_csv(dataobject, \"filename.csv\")\n```\n\nAlternatively, if you are saving data for your own purposes or to share with a colleague with also uses R, you can create an rda or RData file. rda files are a short form of RData files. The advantages of using RData files include\n\n-   more quickly restoring data to R for further analysis or wrangling\n\n-   keeping R specific information encoded in the data (e.g., attributes like factor level order, variable types, etc.)\n\n-   the option to save multiple objects or tibbles in one file\n\nThe functions to save and load RData files are conveniently save() and load(), which work as follows:\n\n```{{r}}\n#to save one object\nsave(dataobject, \"filename.rda\")\n \n#to save more than obe object\nsave(dataobject1, dataobject2, \"filename.rda\")\n \n#to read in your RData file\nload(\"filename.rda\")\n```\n\n![](images/week4.1.rdata_example.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n",
    "supporting": [
      "topic-1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}